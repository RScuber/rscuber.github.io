{"meta":{"title":"Hexo","subtitle":"","description":"","author":"袁成让","url":"https://rscuber.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2021-11-10T16:25:55.000Z","updated":"2021-11-21T16:44:40.742Z","comments":false,"path":"categories/index.html","permalink":"https://rscuber.github.io/categories/index.html","excerpt":"","text":""},{"title":"随笔","date":"2021-11-12T05:52:46.000Z","updated":"2021-11-12T05:54:08.276Z","comments":false,"path":"tags/index.html","permalink":"https://rscuber.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hexo的简单使用","slug":"hexo的简单使用","date":"2021-12-09T09:29:46.803Z","updated":"2021-12-09T09:29:46.803Z","comments":true,"path":"archives/73f466e7.html","link":"","permalink":"https://rscuber.github.io/archives/73f466e7.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://rscuber.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://rscuber.github.io/tags/Hexo/"},{"name":"工具","slug":"工具","permalink":"https://rscuber.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"祖国，或以梦为马","slug":"祖国，或以梦为马","date":"2021-12-09T07:07:10.000Z","updated":"2021-12-14T14:56:58.261Z","comments":true,"path":"archives/a01416cb.html","link":"","permalink":"https://rscuber.github.io/archives/a01416cb.html","excerpt":"海子我要做远方的忠诚的儿子和物质的短暂情人和所有以梦为马的诗人一样我不得不和烈士和小丑走在同一道路上","text":"海子我要做远方的忠诚的儿子和物质的短暂情人和所有以梦为马的诗人一样我不得不和烈士和小丑走在同一道路上 万人都要将火熄灭我一人独将此火高高举起此火为大 开花落英于神圣的祖国和所有以梦为马的诗人一样我借此火得度一生的茫茫黑夜 此火为大 祖国的语言和乱石投筑的梁山城寨以梦为上的敦煌——那七月也会寒冷的骨骼如雪白的柴和坚硬的条条白雪 横放在众神之山和所有以梦为马的诗人一样我投入此火 这三者是囚禁我的灯盏 吐出光辉 万人都要从我刀口走过 去建筑祖国的语言我甘愿一切从头开始和所有以梦为马的诗人一样我也愿将牢底坐穿 众神创造物种只有我最易朽 带着不可抗拒的死亡的速度只有粮食是我珍爱 我将她紧紧抱住抱住她在故乡生儿育女和所有以梦为马的诗人一样我也愿将自己埋葬在四周高高的山上守望平静的家园 面对大河我无限惭愧我年华虚度 空有一生疲倦和所有以梦为马的诗人一样岁月易逝 一滴不剩 水滴中有一匹马儿一命归天 千年后如若我再生于祖国的河岸千年后我再次拥有中国的稻田和周天子的雪山天马踢踏 我选择永恒的事业 我的事业 就是要成为太阳的一生他从古至今日 他无比辉煌 无比光明和所有以梦为马的诗人一样最后我被黄昏的众神抬入不朽的太阳 太阳是我的名字太阳是我的一生太阳的山顶埋葬 诗歌的尸体——千年王国和我骑着五千年凤凰和名字叫“马”的龙——我必将失败但诗歌本身以太阳必将胜利","categories":[{"name":"诗歌","slug":"诗歌","permalink":"https://rscuber.github.io/categories/%E8%AF%97%E6%AD%8C/"}],"tags":[{"name":"文学","slug":"文学","permalink":"https://rscuber.github.io/tags/%E6%96%87%E5%AD%A6/"},{"name":"诗歌","slug":"诗歌","permalink":"https://rscuber.github.io/tags/%E8%AF%97%E6%AD%8C/"}]},{"title":"考研英语每日长难句","slug":"考研英语每日长难句","date":"2021-12-03T09:05:15.000Z","updated":"2021-12-27T11:46:09.275Z","comments":true,"path":"archives/f2d4a442.html","link":"","permalink":"https://rscuber.github.io/archives/f2d4a442.html","excerpt":"考研英语每日长难句[2021.10.14]After the first installment, Dickens wrote to the artist and asked him to correct a drawing Dickens felt was not faithful enough to his prose.","text":"考研英语每日长难句[2021.10.14]After the first installment, Dickens wrote to the artist and asked him to correct a drawing Dickens felt was not faithful enough to his prose.【结构分析】本句是简单句。句子主干是Dickens wrote to the artist and asked him to correct a drawing。Dickens felt was not faithful enough to his prose是省略了that的定语从句,修饰a drawing。【重点词汇】installment n.部分prose n.散文【参考译文】在刊载了故事的第一期之后，狄更斯致信给西蒙，要求他修改一幅狄更斯认为并不足以忠实于其表述的画作。 [2021.10.15]With characteristic confidence, Dickens successfully insisted that Seymour’s pictures illustrate his own story instead. 【结构分析】本句是复合句。句子主干是Dickens insisted。that宾语从句做insisted的宾语。【重点词汇】confidence n.自信illustrate v.举例说明，图解【参考译文】狄更斯以其特有的自信，成功地坚持认为西摩的画描绘了他自己的故事。 [2021.10.18]There were Pickwick coats and Pickwick cigars, and the plump, spectacled hero, Samuel Pickwick, became a national figure. 【结构分析】本句是个并列句。句子主干是There were Pickwick coats and Pickwick cigars，and the plump, spectacled hero became a national figure。Samuel Pickwick是hero的同位语。【重点词汇】plump adj.圆胖的，丰满的spectacled adj.戴了眼镜的figure n.外形；体形；数字；人物【参考译文】当时出现了匹克威克大衣和匹克威克香烟，而体型滚圆、戴着眼镜的英雄缪尔.匹克威克也成为了国民人物。 [2021.10.19]The runaway success of The Pickwick Papers, as it is generally known today, secured Dickens’s fame. 【结构分析】本句是个简单句。句子主干是The runaway success of The Pickwick Papers secured Dickens’s fame。【重点词汇】runaway adj.巨大的；遥遥领先的 n.逃跑；逃跑者；巨大的胜利secure adj.安全的，可靠的 v.保护【参考译文】如今众所周知的《匹克威克外传》在当时名声大噪，狄更斯的名望也由此确立。 [2021.10.20]From then on his sketches, which appeared under the pen name “Boz” in The Evening Chronicle, earned him a modest reputation. 【结构分析】本句是个简单句。句子主干是his sketches earned him a modest reputation，为earn sb. sth.的结构。which引导的非限制性定语从句修饰sketches，其中，which作主语，appeared作谓语。【重点词汇】chronicle n.编年史【参考译文】在那之后，他以“博兹”为笔名在《晚间纪事》上发表的短篇小说，为他赢得了一定的赞誉。 [2021.10.21]The first published sketch, “A Dinner at Poplar Walk” brought tears to Dickens’s eyes when he discovered it in the pages of The Monthly Magazine. 【结构分析】本句是复合句。句子主干是The first published sketch brought tears。when引导时间状语从句，从句的主干是he discovered it。“A Dinner at Poplar Walk”为The first published sketch的同位语。【重点词汇】sketch n.略图，概略；速写【参考译文】当狄更斯发现他的第一篇短篇作品《白杨庄晚宴》公开发表在《每月杂志》上时，他热泪盈眶 [2021.10.22]Two- and three-dimensional maps are helpful tools in planning excavations, illustrating how sites look, and presenting the results of archaeological research. 【结构分析】本句是复合句。Two- and three-dimensional maps是主语，are是系动词，helpful tools是表语。in planning excavations，illustrating…，and presenting…是tools的后置定语，其中how引导illustrating的宾语从句。【重点词汇】two- and three-dimensional maps 二维和三维地图【参考译文】在规划挖掘地点、展示遗址样貌及呈现考古研究成果时，二维和三维地图是非常有用的工具。 [2021.10.25]They often include a certain amount of digging to test for buried materials at selected points across a landscape. 【结构分析】本句是个简单句。They是主语，include是谓语，a certain amount of digging是宾语，to test for buried materials是目的状语。【重点词汇】dig v.挖掘selected point 选定地点【参考译文】这种勘测通常包括在某一区域的选定地点进行大量挖掘来检测被埋物质。 [2021.10.26]Most ground surveys involve a lot of walking, looking for surface clues such as small fragments of pottery. 【结构分析】本句是个简单句。Most ground surveys是主语，involve是谓语，a lot of walking是宾语，looking for surface clues…是伴随状语。【重点词汇】fragment n.碎片pottery n.陶器【参考译文】多数地面勘测工作需要进行很多的长途跋涉，寻找诸如小陶器碎片一类的地表线索。 [2021.10.27]Evans’s interpretations of these engravings eventually led him to find the Minoan palace at Knossos (Knosós), on the island of Crete, in 1900. 【结构分析】本句是个简单句。Evans’s interpretations是主语，of these engravings是interpretations的后置定语，led是谓语，him是宾语，to find the Minoan palace是宾语补足语。【重点词汇】eventually adv.最后【参考译文】埃文斯对那些雕刻的解读最终使他于1900年在克里特岛的科诺索斯找到了米思诺王宫。 [2021.11.01]Most archaeological sites, however, are discovered by archaeologists who have set out to look for them. 【结构分析】本句是个复合句。Most archaeological sites是主语，are discovered是谓语，who have set out to look for them是定语从句修饰archaeologists。【重点词汇】archaeological sites 考古遗址【参考译文】然而，大多数考古遗址是考古学家特意搜寻才被发现的。 [2021.11.02]Aerial surveys locate general areas of interest or larger buried features, such as ancient buildings or fields. 【结构分析】本句是个简单句。Aerial surveys是主语，locate是谓语，general areas of interest or larger buried features是宾语。【重点词汇】field n.场地feature n.特征，面貌【参考译文】空中勘测可以定位大致的目标区域或较大面积遗址的地表特征，如古建筑或战场。 [2021.11.03]The resulting settlement maps show how the distribution and density of the rural population around the city changed dramatically between AD 500 and 850, when Copán collapsed. 【结构分析】本句是个复合句。The resulting settlement maps是主语，show是谓语，后接how引导的宾语从句，后面还含有时间状语从句。【重点词汇】distribution n.分布density n.密度dramatically adv.戏剧性地collapse v.崩塌【参考译文】由此绘制出来的居住图反映了在公元500至850年科藩陷落期间古城周边村落人口分布和密度是如何发生巨大变化的。 [2021.11.04]Typically, they survey and sample (make test excavations on) large areas of terrain to determine where excavation will yield useful information. 【结构分析】本句是个复合句。they是主语，survey and sample是谓语，large areas of terrain是宾语，to determine是不定式作目的状语，where excavation will yield useful information是to determine的宾语从句。【重点词汇】survey v.勘测sample v.抽样excavation n.挖掘terrain n.地形，地势，地面yield v.生产，产出【参考译文】典型的做法是，他们对大面积区域进行勘测和抽样检验（试验挖掘），以确定哪儿会挖出有用信息。 [2021.11.05]How do archaeologists know where to find what they are looking for when there is nothing visible on the surface of the ground? 【结构分析】本句是个复合句。How do archaeologists know where是疑问句的主句部分，其中主语是archaeologists，know是谓语动词，where引导宾语从句；what they are looking for是to find的宾语从句，when there is nothing visible on the surface of the ground是时间状语从句。【重点词汇】visible adj.看得见的【参考译文】在地表上什么也看不见的情况下，考古学家怎么知道哪儿能找到他们要寻找的遗址呢？ [2021.11.08]The researchers mapped not only the city’s vast and ornate ceremonial areas, but also hundreds of simpler apartment complexes where common people lived. 【结构分析】本句是个复合句。The researchers是主语，mapped是谓语，ceremonial areas和apartment complexes是并列宾语，where common people lived是定语从句修饰apartment complexes。【重点词汇】ornate adj.华丽的ceremonial adj.仪式的complex n.建筑群【参考译文】研究人员不仅测绘出了这座城市广阔、华丽的仪式区域，还测绘出了几百处普通人居住的较为简单的公寓建筑群。 [2021.11.09]In another case, American archaeologists René Million and George Cowgill spent years systematically mapping the entire city of Teotihuacán in the Valley of Mexico near what is now Mexico City. 【结构分析】本句是个复合句。René Million and George Cowgill是主语，spent是谓语，years是宾语，mapping the entire city of Teotihuacán是主语补足语，in the Valley of Mexico是地点状语，near what is now Mexico City是定语从句修饰the Valley of Mexico。【重点词汇】systematically adv.有系统地map v.绘制地图entire adj.整个的【参考译文】在另外一个考古实例中，美国考古学家勒内.米丽翁和乔治.考吉尔花了数年时间系统测绘了位于今天墨西哥城附近的墨西哥山谷中的整个特奥迪瓦肯城。 [2021.11.10]Surveys and test samples have also become important for understanding the larger landscapes that contain archaeological sites. 【结构分析】本句是复合句。Surveys and test samples是主语，have also become是系动词，important是表语，for understanding the larger landscapes是范围状语，that contain archaeological sites是定语从句修饰landscapes。【重点词汇】landscape n.地形；景致【参考译文】勘测和抽样分析对了解包含考古遗址的更大面积区域的地形特征都有重要作用。 [2021.11.11]The key to reforming higher education, concludes Mr. Menand, is to alter the way in which “the producers of knowledge are produced.” 【结构分析】本句是个复合句。The key是主语，is是系动词，to alter the way是表语，in which引导定语从句。【重点词汇】reform v.改革alter v.改变【参考译文】梅南德先生总结道，高等教育改革的关键是改变“知识生产者”的生产方式。 [2021.11.12]Otherwise, academics will continue to think dangerously alike, increasingly detached from the societies which they study, investigate and criticize.” 【结构分析】本句是个复合句。academics是主语，will continue是谓语，to think dangerously alike是宾语，which they study, investigate and criticize为定语从句修饰societies。【重点词汇】detach v.分离investigate v.调查criticize v.批评【参考译文】否则，学者的所想会更加危险地趋同，日益脱离他们的研究、调查和批判的社会。 [2021.11.16]Some archaeological sites have always been easily observable – for example, the Parthenon in Athens, Greece; the pyramids of Giza in Egypt; and the megaliths of Stonehenge in southern England. 【结构分析】本句是个简单句。Some archaeological sites是主语，have been是系动词，observable是表语，破折号之后表示例证。【重点词汇】archaeological adj.考古学（上）的observable adj.观察得到的Parthenon n.万神庙pyramid n.金字塔megalith n.巨石Stonehenge n.史前巨石柱【参考译文】有些考古遗址总是很容易被发现，例如希腊雅典的帕特农神庙、埃及的吉萨金字塔和英格兰南部的巨石阵。 [2021.11.17]For something curious has been happening in American Universities, and Louis Menand, a professor of English at Harvard University, captures it skillfully. 【结构分析】本句是复合句。Louis Menand是主语，a professor of English at Harvard University是主语的同位语。captures是谓语，it是宾语，for引导原因状语从句。【重点词汇】curious adj.好奇的capture v.捕获skillfully adv.巧妙地【参考译文】因为美国大学正在发生奇怪的事情，哈佛大学的英语教授路易斯.梅南德巧妙地捕捉到了这些。 [2021.11.18]Most archaeological sites have been located by means of careful searching, while many others have been discovered by accident. 【结构分析】本句是并列句。Most archaeological sites have been located是第一个分句的主干部分，many others have been discovered是第二个分句的主干部分。【重点词汇】locate v.定位by means of 依靠，借助于【参考译文】多数考古遗址都是经过仔细搜寻才发现的，而另外很多遗址则是偶然间被发现的。 [2021.11.19]Olduvai Gorge, an early hominid site in Tanzania, was found by a butterfly hunter who literally fell into its deep valley in 1911. 【结构分析】本句是个复合句。Olduvai Gorge是主语，was found是谓语，by a butterfly hunter是方式状语，who literally fell into its deep valley in 1911是定语从句修饰hunter。【重点词汇】hominid adj.人科的【参考译文】奥杜伟峡谷是一处位于坦桑尼亚的早期人类遗址，是1911年一个正好掉进这条深谷的捕蝶人发现的。 [2021.11.30]But fewer students want to study humanities subjects: English departments awarded more bachelor’s degrees in 1970-71 than they did 20 years later. 【结构分析】本句是个复合句。fewer students want to study humanities subjects是主句，冒号后作进一步解释说明。【重点词汇】department n.部门，系award v.授予bachelor n.学士degree n.学位【参考译文】但是想要学习人文学科的学生越来越少：1970-1971年间英语部授予的学士学位比20年后还要多。 [2021.12.1]Equally unsurprisingly, only about half end up with professorships for which they entered graduate school. 【结构分析】本句是复合句。only about half end up with professorships是主句，后接for which引导的定语从句修饰professorships。【重点词汇】equally adj.同样地professorship n.教授职位【参考译文】同样不足为奇的是，为了教授头衔进入研究生院的学生中只有约一半的人最终获得了教授职位 [2021.12.2]At Harvard, Mr. Menand notes, “the great books are read because they have been read”—they form a sort of social glue. 【结构分析】本句是个复合句。Mr. Menand是主语，notes是谓语，双逗号内为宾语从句，破折号后的部分作进一步的解释说明。【重点词汇】glue n.胶粘物【参考译文】在哈佛大学，梅南德发现，“学生之所以阅读伟大的著作是因为它们之前一直被人阅读”这些著作成为了一种社会黏合剂。 [2021.12.3]However, many leading American universities want their undergraduates to have a grounding in the basic canon of ideas that every educated person should possess. 【结构分析】本句是个复合句。many leading American universities是主语，want是谓语，their undergraduates是宾语，to have a grounding是不定式作宾语补足语；in the basic canon of ideas是grounding的后置定语，that every educated person should possess为定语从句修饰canon of ideas。【重点词汇】undergraduate n.大学生grounding n.基础canon n.准则possess v.掌握【参考译文】然而，很多美国一流大学都要求其本科生在每个受教育者都应掌握的基本思想准则方面接受基础训练。 [2021.12.6]For example, wholesale food and drink sales come to $268 billion in France, Germany, Italy, Spain, and the United Kingdom in 2000—more than 40 percent of retail sales. 【结构分析】本句是简单句。wholesale food and drink sales是主语，come是谓语。【重点词汇】wholesale n.批发come to 达到了……retail n.零售业【参考译文】例如，2000年，法、德、意、西和英的食品饮料批发业销售额达到了1680亿美元，比零售业销售额高出40%还多。 [2021.12.7]Overall, Europe’s wholesale market for food and drink is growing at the same sluggish pace as the retail market, but the figures, when added together, mask two opposing trends. 【结构分析】本句是并列句。Europe’s wholesale market是第一个分句的主语，is growing是谓语；the figures是第二个分句的主语，mask是谓语，two opposing trends是宾语。【重点词汇】overall adv.总地sluggish adj.缓慢的figure n.数字mask v.掩盖opposing adj.对立的trend n.趋向【参考译文】总体是，欧洲食品饮料批发市场的增长速度和零售市场一样慢，但是当这两个数据相加，却掩盖了两种相反的趋势。 [2021.12.8]Such food service operators range from snack machines to large institutional catering ventures, but most of these businesses are known in the trade as “horeca”: hotels, restaurants, and cafes. 【结构分析】本句是个并列句。Such food service operators是第一个分句的主语，range是谓语；most of these businesses是第二个分句的主语，are known是谓语。【重点词汇】operator n.经营者cater v.提供服务；迎合【参考译文】这种饮食服务经营者有快餐售卖机，也有大型餐饮企业，但是这类经营者多数在行业内被称为“三馆”：旅馆、餐馆和咖啡馆。 [2021.12.9]These are disciplines that are going out of style: 22% of American college graduates now major in business compared with only 2% in history and 4% in English. 【结构分析】本句是个复合句。These是主语，are是系动词，disciplines是表语，后接that引导的定语从句，修饰表语，冒号后的部分作了进一步的解释说明。【重点词汇】graduate n.毕业生major v.主修【参考译文】这些学科渐渐过时了：如今22%的美国大学毕业生主修商科，相比较而言，只有2%主修历史，4%主修英语。 [2021.12.13]Big retailers must understand these differences before they can identify the segments of European wholesaling in which their particular abilities might unseat smaller but entrenched competitors. 【结构分析】本句是个复合句。Big retailers是主语，must understand是谓语，these differences是宾语，后含before引导的时间状语从句和in which引导的定语从句。【重点词汇】identify v.确定particular adj.特别的unseat v.革除entrenched adj.牢固的competitor n.竞争者【参考译文】大型零售商必须先了解这些差异，才能找到欧洲批发业中可凭自己的特殊能力将规模小但地位稳固的竞争对手挤走的部门。 [2021.12.14]Retailers that master the intricacies of wholesaling in Europe may well expect to rake in substantial profits thereby. 【结构分析】本句是个复合句。Retailers是主语，may expect是谓语，后为宾语，主语后接that引导的定语从句修饰主语。【重点词汇】intricacy n.错综复杂rake v.梳理，搜寻substantial adj.大量的【参考译文】因此，那些掌握了欧洲批发业复杂性的零售商很可能会轻而易举赚到可观的利润。 [2021.12.15]At any rate, this change will ultimately be acclaimed by an ever-growing number of both domestic and international consumers, regardless of how long the current consumer pattern will take hold. 【结构分析】本句是个复合句。this change是主语，will be acclaimed是谓语，后含有一个regardless of引导的让步状语从句。【重点词汇】ultimately adv.最终acclaim v.称赞domestic adj.国内的pattern n.模式【参考译文】无论如何，不管现在的消费模式还会持续多久，这种变化终将会受到越来越多国内外消费者的欢迎。 [2021.12.16]But almost all have ignored the big, profitable opportunity in their own backyard: the wholesale food and drink trade, which appears to be just the kind of market retailers need. 【结构分析】本句是个复合句。all是主语，have ignored是谓语，the opportunity是宾语，后含有一个which引导的非限定性定语从句。【重点词汇】ignore v.忽视profitable adj.有利可图的【参考译文】但是几乎所有人都忽视了在自家后院的巨大盈利机会：食品饮料批发贸易，这似乎正是零售商需要的市场。 [2021.12.17]Retail sales of food and drink in Europe’s largest markets are at a standstill, leaving European grocery retailers hungry for opportunities to grow. 【结构分析】本句是个简单句。Retail sales是主语，are是系动词，at a standstill是表语。【重点词汇】standstill n.停顿，停止grocery n.食品杂货店【参考译文】欧洲最大市场的食品和饮料零售销售处于停滞状态，使得欧洲食品杂货零售商渴望销售增长的机会。【本句选自2010年英语（一）新题型真题P2S1】 [2021.12.20]This development is boosting wholesale demand from the food service segment by 4 to 5 percent a year across Europe, compared with growth in retail demand of 1 to 2 percent. 【结构分析】本句是个简单句。This development是主语，is boosting是谓语，wholesale demand是宾语。【重点词汇】boost v.增加，促进wholesale n.批发segment n.部分retail n.零售【参考译文】这种发展正在促使整个欧洲食品服务部门一年的批发需求增长4%-5%，相比之下，零售需求的年增长率只有1%-2%。 [2021.12.21]So when the premiers gather in Niagara Falls to assemble their usual complaint list, they should also get cracking about something in their jurisdiction that would help their budgets and patients. 【结构分析】本句是个复合句。they是主语，should get cracking是谓语，about something是宾语，后面有一个that引导的定语从句修饰something。【重点词汇】assemble v.集合，收集jurisdiction n.管辖权，权限get cracking 开始【参考译文】因此，当省长们聚集在尼亚加拉瀑布城，像往常那样抱怨不已时，他们也应该在自己的职权范围内开始做些有利于他们的预算及病人的事情。 [2021.12.22]Under it, a Common Drug Review recommends to provincial lists which new drugs should be included. 【结构分析】本句是个复合句。a Common Drug Review是主语，recommends是谓语，后接which引导的宾语从句。【重点词汇】common adj.公共的recommend v.推荐【参考译文】该办公室下设的公共药物评估机构推荐各省应该在清单上增加哪些新药。 [2021.12.23]A small step has been taken in the direction of a national agency with the creation of the Canadian Co-ordinating Office for Health Technology Assessment, funded by Ottawa and the provinces. 【结构分析】本句是个简单句。A small step是主语，has been taken是谓语。【重点词汇】assessment n.评估【参考译文】加拿大医疗技术评估联合协作办公室的创立意味着向成立国家机构迈进了一小步，此部门有渥太华和其他各省出资组建。 [2021.12.24]Instead of having one province — or a series of hospitals within a province — negotiate a price for a given drug on the provincial list, the national agency would negotiate on behalf of all provinces. 【结构分析】本句是个简单句。the national agency是主语，would negotiate是谓语。【重点词汇】negotiate v.谈判，协商province n.省份【参考译文】由原来的一个省或省内的几家医院对该省清单上的某种药物与生产商议价，变成国家机构代表所有省份来议价。 [2021.12.20]This development is boosting wholesale demand from the food service segment by 4 to 5 percent a year across Europe, compared with growth in retail demand of 1 to 2 percent. 【结构分析】本句是个简单句。This development是主语，is boosting是谓语，wholesale demand是宾语。【重点词汇】boost v.增加，促进wholesale n.批发segment n.部分retail n.零售【参考译文】这种发展正在促使整个欧洲食品服务部门一年的批发需求增长4%-5%，相比之下，零售需求的年增长率只有1%-2%。","categories":[{"name":"英语","slug":"英语","permalink":"https://rscuber.github.io/categories/%E8%8B%B1%E8%AF%AD/"}],"tags":[{"name":"英语","slug":"英语","permalink":"https://rscuber.github.io/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"长难句","slug":"长难句","permalink":"https://rscuber.github.io/tags/%E9%95%BF%E9%9A%BE%E5%8F%A5/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2021-11-25T09:27:37.000Z","updated":"2021-12-09T09:26:43.280Z","comments":true,"path":"archives/3c50d03d.html","link":"","permalink":"https://rscuber.github.io/archives/3c50d03d.html","excerpt":"Markdown 基础语法1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。","text":"Markdown 基础语法1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 2. 分级标题使用 === 表示一级标题，使用 —- 表示二级标题。 示例： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接使用 [描述](链接地址) 为文字增加外链接。 示例： 这是去往 本人博客 的链接。 4. 无序列表使用 *，+，- 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 7. 行内代码块使用 `代码` 表示行内代码块。 示例： 让我们聊聊 html。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 示例： Markdown 进阶语法1. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 3. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 4. 注脚使用 keyword 表示注脚。 这是一个注脚footnote的样例。 这是第二个注脚footnote2的样例。 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 表示整行公式： $$\\sum_{i=1}^n a_i=0f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k}访问 MathJax 参考更多使用方法。 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0): &#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27; if param1 &gt; param2: # interesting print &#x27;Greater&#x27; return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27; JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 流程图示例12345678910st=&gt;start: Start:&gt;https://rscuber.github.ioio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考9. 甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 更多语法参考：甘特图语法参考10. Mermaid 流程图1234A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two] 更多语法参考：Mermaid 流程图语法参考11. Mermaid 序列图1234Alice-&gt;John: Hello John, how are you?loop every minute John--&gt;Alice: Great!end 更多语法参考：Mermaid 序列图语法参考12. 表格支持 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 13. 定义型列表名词 1: 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 14. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 15. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 16. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： [ ] Cmd Markdown 开发 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [ ] 支持以 PDF 格式导出文稿 [x] 新增Todo列表功能 语法参考 [x] 改进 LaTex 功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 语法参考 [ ] 七月旅行准备 [ ] 准备邮轮上需要携带的物品 [ ] 浏览日本免税店的物品 [x] 购买蓝宝石公主号七月一日的船票 footnote. 这是一个 注脚 的 文本。 &#8617; footnote2. 这是另一个 注脚 的 文本。 &#8617;","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://rscuber.github.io/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://rscuber.github.io/tags/Markdown/"}]},{"title":"Python面向对象编程","slug":"python面向对象编程","date":"2021-11-21T15:11:45.000Z","updated":"2021-12-09T17:27:53.592Z","comments":true,"path":"archives/59dd15a2.html","link":"","permalink":"https://rscuber.github.io/archives/59dd15a2.html","excerpt":"面向对象-OOP 面向对象编程——Object Oriented Programming，简称OOP，是一种以对象为中心的程序设计思想。 面向过程编程——Procedure Oriented Programming，简称POP，是一种以过程为中心的程序设计思想。","text":"面向对象-OOP 面向对象编程——Object Oriented Programming，简称OOP，是一种以对象为中心的程序设计思想。 面向过程编程——Procedure Oriented Programming，简称POP，是一种以过程为中心的程序设计思想。 理解面向过程与面向对象思想大家先思考一个问题：把大象装进冰箱，需要几步？ 小品给出的答案：三步 第一步：打开冰箱门 第二步：把大象装进去 第三步：关上冰箱门 用面向过程去理解 上面给出的答案就是面向过程的，遇到问题后，分析解决问题的步骤，然后一步步去实现 用面向对象去理解 是通过分析问题中需要的抽象模型，然后更具需要的功能分别去创建模型对象，最终由模型对象来完成程序 首先面向对象要解决这个问题，需要先建立出抽象模型，比如：打开冰箱门和关闭冰箱门，这都属于一个冰箱的功能，大象走进去，这就是大象的功能。到此时我们就出现了两个抽象模型，一个是冰箱，一个是大象。 冰箱具有 打开和关闭的功能，大象具有走路的能力。 分析到这里，就是面向对象的思想，具体完成的话，就是去创建冰箱和大象这两个对象，最终完成这个程序 冰箱对象-开门，大象对象-走进冰箱，冰箱对象-关门 面向过程和面向对象的区别和优缺点？一，面向过程 面向过程的核心是过程，过程就是指解决问题的步骤。 优缺点： 优点： 将负责的问题流程化，进而实现简答化 缺点：扩展性差（更新，维护，迭代） 总结：在去完成一些简单的程序时，可以使用面向过程去解决。但是如果有复杂的程序或任务，而且需要不断的进行迭代和维护，那么肯定是优先选择面向对象的编程思想 二，面向对象 面向对象的核心是对象，是一个特征和功能的综合体 优缺点： 优点：可扩展性高 缺点：编程复杂度相对面向过程高一些。指的是计算机在执行面向对象的程序时的性能表现 如何去学习面向对象编程？ 理解面向对象编程的思想 学习面向对象编程的语法 认识类与对象类：类是对象的一个抽象的概念 对象（实例）：对象就是由类的创建的实例 类和对象的关系就是 模具与铸件的关系 类是由对象总结而来的，总结的这个过程叫做抽象 对象是由类具体实施出来的，这个过程叫做实例化 面向对象编程的基本实现 如果需要实例一个对象，那么需要先抽象一个类 例如需要创建一个汽车对象 首先需要抽象一个汽车类：汽车类就相当于一个设计图纸一样。 由这个设计图纸去创建(实例)出来的真实汽车就是一个对象 如何创建一个类，通过class关键字来定义一个类 示例： 123456789# 定义一个汽车的类class Car(): pass&#x27;&#x27;&#x27;类名的书写规范，建议使用驼峰命名法 大驼峰：MyCar XiaoMi 小驼峰：myCar xiaoMi&#x27;&#x27;&#x27; 类中需要声明什么内容？ 12345678一个类有特征和功能两个内容组成： 特征就是一个描述：颜色：黑色，品牌：奥迪。。。 功能就是一个能力：驾驶。。。。 特征在编程中就是一个变量，在类中称为 属性 功能在编程中就是一个函数，在类中称为 方法类中属性一般定义在前面，方法定义在后面 示例： 12345678910# 定义一个汽车的类class Car(): # 属性 ==&gt; 特征 ==&gt; 变量 color = &#x27;black&#x27; # 表示颜色属性 brand = &#x27;audi&#x27; # 表示品牌属性 # 方法 ==&gt; 功能 ==&gt; 函数 def drive(self): print(&#x27;dirve the car&#x27;) return 如何通过类实例化对象并使用？ 123456789101112# 如何去使用这个类？# 通过类实例化一个对象aodiobj = Car()# print(aodiobj,type(aodiobj))# &lt;__main__.Cart object at 0x106f08550&gt; &lt;class &#x27;__main__.Car&#x27;&gt;# 调用对象的方法aodiobj.drive()# 获取对象的属性print(aodiobj.brand) 成员属性和成员方法的操作对象操作成员1234567891011成员属性： 访问： 对象.成员属性名 修改： 对象.成员属性名法 = 新值。（此时等于给这个对象创建了一个自己的属性） 添加： 对象.新成员属性 = 值 (此时是给这个对象自己新建了一个属性) 删除： del 对象.成员属性 (注意：只能删除这个对象自己的属性)成员方法： 访问： 对象.成员方法名() 修改： 对象.成员方法名 = func（此时等于给这个对象创建了一个自己的方法） 添加： 对象.方法名 = func (此时是给这个对象自己新建了一个方法) 删除： del 对象.方法名 (注意：只能删除这个对象自己的方法) 类操作成员（不推荐）1234567891011成员属性： 访问： 类名.成员属性名 修改： 类名.成员属性名法 = 新值。（此时通过这个类创建的对象都具有这个属性） 添加： 类名.新成员属性 = 值 (此时通过这个类创建的对象都具有这个属性) 删除： del 类名.成员属性 (注意：删除这个类的属性后，这个类创建的对象也没有这几个属性了)成员方法： 访问： 类名.成员方法名() 修改： 类名.成员方法名 = func（此时通过类创建的对象都被修改） 添加： 类名.方法名 = func (此时通过类创建的对象都被修改) 删除： del 类名.方法名 (注意：此时通过类创建的对象都被修改) 总结 一个类可以实例化出多个对象，每个对象在内存中都独立存在的 当通过类实例化对象时，并不会把类中的成员复制一份给对象，而去给对象了一个引用 访问对象成员的时候，如果对象自己没有这个成员，对象会向实例化它的类去查找 对象成员的添加和修改，都只会影响当前对象自己，不会影响类和其它对象 删除对象的成员时，必须是该对象自己具备的成员才可以，不能删除类中引用的成员 对类的成员操作，会影响通过这个类创建的对象，包括之前创建的。 成员方法中的self self在方法中只是一个形参，并不是关键字 self 单词本身的意思 自己 self 在类的方法中 代表 当前这个对象 self 代表调用这个方法的对象,谁调用了这个方法，self就代表谁 self 就可以在类的内部代替对象进行各种操作 方法的分类 含有self或者可以接受对象作为参数的方法： 非绑定类方法 不含self或者不能接受对象作为参数的方法：绑定类方法 非绑定类方法，可以使用对象去访问 绑定类方法，只能通过类去访问 魔术方法 魔术方法也和普通方法一样都是类中定义的成员方法魔术方法不需要去手动调用的，魔术方法会在某种情况下，自动触发（自动执行）魔术方法还有一个比较特殊的地方：就是多数的魔术方法 前后都有两个连续的下划线魔术方法不是我们自己定义的，而是系统定义好的，我们来使用 __init__初始化方法1234__init__ 初始化方法 触发机制：在通过类实例化对象后，自动触发的一个方法 作用： 可以在对象实例化后完成对象的初始化（属性的赋值，方法的调用。。） 应用场景： 文件的打开，数据的获取。。。干活前的一些准备功能。。。 __del__析构方法123456789__del__ 析构方法 触发机制：析构方法会在对象被销毁时自动触发 作用：关闭一些开发的资源 注意：是对象被销毁时触发了析构方法，而不是析构方法销毁了对象对象会在哪些情况下被销毁？ 1。 当程序执行完毕，内存中所有的资源都会被销毁释放 2。 使用 del 删除时 3。 对象没有被引用时，会自动销毁 示例： 定义一个类，完成一个日志的记录调用这个对象的时候，传递一个日志信息这个对象会创建一个文件，开始写入，并在最后关闭这个文件 123456789101112131415161718192021222324import timeclass writeLog(): # 成员属性 # 文件的路径 fileurl = &#x27;./&#x27; # 日志文件的名称 filename = &#x27;2021-11-12&#x27; # 初识化 打开文件 def __init__(self): #完成文件的打开 print(&#x27;初始化方法触发类。完成文件的打开&#x27;) self.fileobj = open(self.fileurl+self.filename,&#x27;a+&#x27;,encoding=&#x27;utf-8&#x27;) # 写日志的方法 def log(self,s): print(f&#x27;把日志：&#123;s&#125; 写入文件中&#x27;) # 析构方法 def __del__(self): print(&#x27;析构方法触发了，关闭打开的文件&#x27;) # 在对象被销毁时，关闭在初始化方法中打开的文件对象 self.fileobj.close() 面向对象-高阶内置成员1234567891011121314151617181920# 获取类/对象的所属成员 类/对象.__dict__res = Demo.__dict__ # 获取当前类的所属成员res = obj.__dict__ # 获取当前对象的所属成员# 获取类的文档信息 类/对象.__doc__res = Demo.__doc__res = obj.__doc__# 获取类名称组成的字符串res = Demo.__name__# 获取类所在的文件名称，如果是当前文件，显示为__main__res = Demo.__module__# __bases__ 获取当前类的父类列表res = Demo.__base__ # 获取继承的第一个父类res = Demo.__bases__ # 获取继承的所有的父类列表# MRO列表 获取当前类的继承链res = Demo.__mro__ 方法的分类12345678910111213141516171819202122231. 对象方法 特征： 1. 在类中定义的方法，含有self参数 2. 含有self的方法，只能使用对象进行调用 3. 该方法会把调用的对象传递进来2. 类方法 特征： 1。在类中定义的方法，使用装饰器 @classmethod 进行了装饰 2。方法中有cls这个行参。不需要实例化对象，直接使用类进行调用 3。会把调用这个方法的类传递进来3. 绑定类方法 特征： 1。在类中定义的方法 2。只能使用类进行调用 3。不会传递对象或者类进来4. 静态方法 特征： 1。在类中定义的方法，使用了 装饰器 @staticmethod 进行了装饰 2。可以使用对象或者类进行调用 3。不会传递对象或者类进来 常用函数1234567891011121314151617181920212223# 检测类和对象相关# issubclass(子类,父类) # 检测一个类是否为另一个类的子类# res = issubclass(D,B)# isinstance(对象,类) # 检测一个对象是否是该类或该类的子类的实例化结果# res = isinstance(d,A)# 操作类和对象成员相关# hasattr(对象/类,&#x27;成员名称&#x27;) 检测类/对象是否包含指定名称的成员# res = hasattr(d,&#x27;name&#x27;)#getattr(对象/类,&#x27;成员名称&#x27;) # 获取类/对象的成员的值# res = getattr(d,&#x27;say&#x27;)# setattr(对象/类,&#x27;成员名称&#x27;,&#x27;成员的值&#x27;) 设置类/对象的成员的属性值res = setattr(d,&#x27;name&#x27;,&#x27;ooo&#x27;)# print(d.name)#delattr(类/对象,&#x27;成员名称&#x27;) 删除类/对象的成员属性 和 del 直接删除对象的成员是一样的结果# delattr(D,&#x27;name&#x27;)# dir() #获取当前对象所以可以访问的成员的列表res = dir(d) 魔术方法 魔术方法就是不需要手动调用就可以自动执行的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561. __init__ 初始化方法 ***** 触发机制：当实例化对象之后就会立即触发的方法 作用： 为当前创建的对象完成一些初始化的操作，比如：成员属性的赋值，方法的调用，打开或创建一些资源。。 参数： 一个self，接受当前对象，其它参数根据需求进行定义即可 返回值： 无 注意事项：无2. __new__ 构造方法 **** 触发机制：实例化对象时自动触发（在__init__之前触发） 作用： 管理控制对象创建的过程 参数： 一个cls 接收当前类，其它参数根据初始化方法的参数进行决定 返回值： 必须返回object.__new__(cls)进行对象的创建，如果没有返回值，则实例化对象的结果为None 注意事项： __new__方法的参数和__init__方法的参数要保持一致，除了第一个参数 必须返回object.__new__(cls)进行对象的创建，如果没有返回值，则实例化对象的结果为None 应用场景：设计模式中的单例设计模式3. __del__ 析构方法 ***** 触发机制：当该类对象被销毁时，自动触发 作用： 关闭或释放对象创建时打开或创建的一些资源 参数： 一个self，接受当前的对象 返回值：无 注意事项： 无4. __call__ *** 触发机制： 把对象当作函数直接调用时自动触发 作用： 一般用于归纳类或对象的操作步骤，方便调用 参数： 一个self接收当前对象，其它参数根据调用需求缺点 返回值： 可有可无5.__len__ 触发机制： 当使用len函数去检测当前对象的时候自动触发 作用： 可以使用len函数检测当前对象中某个数据的信息 参数： 一个self 接收当前对象 返回值： 必须有，并且必须是一个整型 注意事项：len要获取什么属性的值，就在返回值中返回哪个属性的长度即可6.__str__ 触发机制： 当使用str或者print函数对对象进行操作时自动触发 作用： 代码对象进行字符串的返回，可以自定义打印的信息 参数： 一个self，接收当前对象 返回值： 必须有，而去必须是字符串类型的值7.__repr__ 触发机制：在使用repr方法对当前对象进行转换时自动触发 作用： 可以设置repr函数操作对象的结果 参数： 一个self，接收当前对象 返回值： 必须有，而去必须是字符串类型的值 注意：正常情况下，如果没有__str__这个魔术方法，__repr__方法就会代替__str__魔术方法8.__bool__ 触发机制： 当前使用bool函数转换当前对象时，自动触发.默认情况下，对象会转为True 作用： 可以代替对象进行bool类型的转换，可以转换任何数据 参数 ： 一个self 接收对象 返回值： 必须是一个布尔类型的返回值 设计模式面向对象的三大特性：封装，继承，多态封装 封装就是使用特殊的语法，对成员属性和成员方法进行包装，达到保护和隐藏的目的但是一定注意，不能把成员全部封装死，就失去意义了被封装的成员主要是供类的内部使用被特殊语法封装的成员，会有不同的访问的权限 封装的级别1234567封装的级别 成员 ==&gt; 公有的 _成员 ==&gt; 受保护的 （约定俗成，而python没有具体实现） __成员 ==&gt; 私有的 公有的 public 受保护的 protected 私有的 private在类的内部 OK OK OK在类的外部 OK No(python可以) No 封装的实现123456789公有的封装： 定义：默认定义的成员都属于公有成员 特征：公有的成员可以在任何位置进行访问和操作受保护封装 定义：在成员名称前面加一个下划线 _成员名称 特征：受保护的成员和公有成员一样可以在任何位置进行访问，但是一般不要随便访问和操作受保护成员私有的封装 定义：在成员名称前面加两个下划线 __成员名称 特征：私有的成员只能在当前类的内部去访问和操作，不能在类的外部进行操作 查看对象的成员12345# 查看对象的所以成员print(ym.__dict__) # 可以获取当前对象的所有成员信息# print(Person.__dict__) # 可以获取当前类的所有成员信息#&#123;&#x27;name&#x27;: &#x27;杨幂&#x27;, &#x27;_age&#x27;: 28, &#x27;_Person__sanwei&#x27;: &#x27;60 55 60&#x27;&#125; 了解： 在python中并没有实现受保护的封装，属于开发者的约定俗成。 python中的私有化封装是通过改名策略实现的，并不是真正的私有化 继承什么是继承？ 文化的传承，技艺的传承，衣钵的继承。。。 计算机中的继承 在面向对象中，一个类去继承父类，那么这个类就拥有了父类中的所有成员（除了私有成员） 概念： 被其它类继承的类，这个类称为 父类 也叫做 基类 或者 超类 继承其它类的类，这个类称为 子类，也叫做 派生类 继承的意义： 提高代码的重用性，建立新的类与类的关系，方便其它逻辑的操作 继承语法格式12345class 父类(): passclass 子类(父类): pass 继承的特征 在不指定继承的父类时，所有类都继承自object类（系统提供） 了解 子类继承了父类后，就拥有了父类中的所有成员包括魔术方法（除了私有成员） 子类继承父类后，并不会把父类的成员复制给子类，而去引用 子类继承父类后可以重写父类中的方法，叫做 重写 子类重写父类的方法，依然可以使用super().父类方法名()的方式调用父类的方法 子类中如果定义了父类中不存在的方法，称为对父类的扩展 一个父类可以被多个子类继承，还可以存在 链式继承 。 链式继承：A类继承了B类，B类继承了C类，C类继承了D类。。。 单继承和多继承单继承 单继承：一个类只能继承一个父类的方式。 语法格式: 12345class 父类(): passclass 子类(父类): pass 多继承 多继承：一个类去继承多个父类的方式。 语法格式: 12345678class 父亲(): passclass 母亲(): passclass 子类(父亲,母亲): pass 菱形继承（钻石继承）1234 A B C D# D类去继承了B类和C类，然后B类和C类又分别继承了A类，这种继承关系称为 菱形继承 问题：在这种菱形继承关系中，类与类的关系，及super()调用时的顺序 123456789101112131415&#x27;&#x27;&#x27;在定义类后，程序会自动生成一个继承的列表 MRO （Method Realtion Order） 方法关系列表MRO列表生成原则： 1. 子类永远在父类的前面 2. 同一等级的类，按照子类中的继承顺序摆放 3. 先子类，后父类的顺序原则，最终的类时系统提供的object类MRO的调用方法类名.mro()&#x27;&#x27;&#x27;C.mro()# [&lt;class &#x27;C&#x27;&gt;, &lt;class &#x27;F&#x27;&gt;, &lt;class &#x27;M&#x27;&gt;, &lt;class &#x27;HuMan&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]# super()在调用时，并不是查找父类，而是去MRO列表上找上一个类。# super()方法在调用时，会自动把当前self传入到上一级的类的方法中 类关系检测 issubclass() issubclass() 检测一个类是否时另一个类的子类 12345# 检测一个类是否是另一个类的子类res = issubclass(D,B) # True 检测D类是不是B类的子类res = issubclass(D,C) # True 检测D类是不是C类的子类res = issubclass(D,A) # True 检测D类是不是A类的子类res = issubclass(A,D) # False 检测A类是不是D类的子类 多态 对于同一个方法，由于调用的对象不同，产生了不同形态的结果 示例： 1234567891011121314151617181920212223242526272829303132333435# 多态 普通版本# 对于同一个方法，由于调用的对象不同（或者传入的对象不同），最终实现了不同的结果# 定义电脑类class Computer(): # 在电脑类中定义一个 sub 的规范的接口 方法 def usb(self,obj): obj.start()# 定义鼠标类class Mouse(): def start(self): print(&#x27;鼠标启动成功&#x27;)# 定义键盘类class KeyBord(): def start(self): print(&#x27;键盘启动成功了&#x27;)# 定义 U盘 类class Udisk(): def start(self): print(&#x27;U盘启动了&#x27;)# 实例化对象c = Computer() # 电脑对象m = Mouse() # 鼠标对象k = KeyBord() # 键盘对象u = Udisk() # u盘对象# 把不同的设备插入到电脑的usb的接口中c.usb(m)c.usb(k)c.usb(u) 面向对象-高阶-内置成员和魔术方法内置成员1234567891011121314151617181920# 获取类/对象的所属成员 类/对象.__dict__res = Demo.__dict__ # 获取当前类的所属成员res = obj.__dict__ # 获取当前对象的所属成员# 获取类的文档信息 类/对象.__doc__res = Demo.__doc__res = obj.__doc__# 获取类名称组成的字符串res = Demo.__name__# 获取类所在的文件名称，如果是当前文件，显示为__main__res = Demo.__module__# __bases__ 获取当前类的父类列表res = Demo.__base__ # 获取继承的第一个父类res = Demo.__bases__ # 获取继承的所有的父类列表# MRO列表 获取当前类的继承链res = Demo.__mro__ 方法的分类12345678910111213141516171819202122231. 对象方法 特征： 1. 在类中定义的方法，含有self参数 2. 含有self的方法，只能使用对象进行调用 3. 该方法会把调用的对象传递进来2. 类方法 特征： 1。在类中定义的方法，使用装饰器 @classmethod 进行了装饰 2。方法中有cls这个行参。不需要实例化对象，直接使用类进行调用 3。会把调用这个方法的类传递进来3. 绑定类方法 特征： 1。在类中定义的方法 2。只能使用类进行调用 3。不会传递对象或者类进来4. 静态方法 特征： 1。在类中定义的方法，使用了 装饰器 @staticmethod 进行了装饰 2。可以使用对象或者类进行调用 3。不会传递对象或者类进来 常用函数1234567891011121314151617181920212223# 检测类和对象相关# issubclass(子类,父类) # 检测一个类是否为另一个类的子类# res = issubclass(D,B)# isinstance(对象,类) # 检测一个对象是否是该类或该类的子类的实例化结果# res = isinstance(d,A)# 操作类和对象成员相关# hasattr(对象/类,&#x27;成员名称&#x27;) 检测类/对象是否包含指定名称的成员# res = hasattr(d,&#x27;name&#x27;)#getattr(对象/类,&#x27;成员名称&#x27;) # 获取类/对象的成员的值# res = getattr(d,&#x27;say&#x27;)# setattr(对象/类,&#x27;成员名称&#x27;,&#x27;成员的值&#x27;) 设置类/对象的成员的属性值res = setattr(d,&#x27;name&#x27;,&#x27;ooo&#x27;)# print(d.name)#delattr(类/对象,&#x27;成员名称&#x27;) 删除类/对象的成员属性 和 del 直接删除对象的成员是一样的结果# delattr(D,&#x27;name&#x27;)# dir() #获取当前对象所以可以访问的成员的列表res = dir(d) 魔术方法 魔术方法就是不需要手动调用就可以自动执行的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561. __init__ 初始化方法 ***** 触发机制：当实例化对象之后就会立即触发的方法 作用： 为当前创建的对象完成一些初始化的操作，比如：成员属性的赋值，方法的调用，打开或创建一些资源。。 参数： 一个self，接受当前对象，其它参数根据需求进行定义即可 返回值： 无 注意事项：无2. __new__ 构造方法 **** 触发机制：实例化对象时自动触发（在__init__之前触发） 作用： 管理控制对象创建的过程 参数： 一个cls 接收当前类，其它参数根据初始化方法的参数进行决定 返回值： 必须返回object.__new__(cls)进行对象的创建，如果没有返回值，则实例化对象的结果为None 注意事项： __new__方法的参数和__init__方法的参数要保持一致，除了第一个参数 必须返回object.__new__(cls)进行对象的创建，如果没有返回值，则实例化对象的结果为None 应用场景：设计模式中的单例设计模式3. __del__ 析构方法 ***** 触发机制：当该类对象被销毁时，自动触发 作用： 关闭或释放对象创建时打开或创建的一些资源 参数： 一个self，接受当前的对象 返回值：无 注意事项： 无4. __call__ *** 触发机制： 把对象当作函数直接调用时自动触发 作用： 一般用于归纳类或对象的操作步骤，方便调用 参数： 一个self接收当前对象，其它参数根据调用需求缺点 返回值： 可有可无5.__len__ 触发机制： 当使用len函数去检测当前对象的时候自动触发 作用： 可以使用len函数检测当前对象中某个数据的信息 参数： 一个self 接收当前对象 返回值： 必须有，并且必须是一个整型 注意事项：len要获取什么属性的值，就在返回值中返回哪个属性的长度即可6.__str__ 触发机制： 当使用str或者print函数对对象进行操作时自动触发 作用： 代码对象进行字符串的返回，可以自定义打印的信息 参数： 一个self，接收当前对象 返回值： 必须有，而去必须是字符串类型的值7.__repr__ 触发机制：在使用repr方法对当前对象进行转换时自动触发 作用： 可以设置repr函数操作对象的结果 参数： 一个self，接收当前对象 返回值： 必须有，而去必须是字符串类型的值 注意：正常情况下，如果没有__str__这个魔术方法，__repr__方法就会代替__str__魔术方法8.__bool__ 触发机制： 当前使用bool函数转换当前对象时，自动触发.默认情况下，对象会转为True 作用： 可以代替对象进行bool类型的转换，可以转换任何数据 参数 ： 一个self 接收对象 返回值： 必须是一个布尔类型的返回值 成员相关魔术方法123456789101112131415161718192021222324252627282930313233## 1. __getattribute__ 优先级最高 触发机制：当访问对象成员时，自动触发，无论当前成员是否存在 作用： 可以在获取对象成员时，对数据进行一些处理 参数： 一个self接收对象，一个item接收当前访问的成员名称 返回值： 可有可无，返回的值就是访问的结果 注意事项：在当前的魔术方法中，禁止对当前对象的成员进行访问，会触发递归。 如果想要在当前魔术方法中访问对象的成员必须使用 object 来进行访问 格式： object.__getattribute__(self,item)## 2. __getattr__ 触发机制： 当访问对象中不存在的成员时，自动触发 作用： 防止访问不存在的成员时报错，也可以为不存在的成员进行赋值操作 参数： 一个self接收当前对象，一个item接收当前访问的成员名称 返回值： 可有可无 注意事项： 当存在 __getattribute__ 方法时，会去执行 __getattribute__ 方法 也要注意，不要在当前的方法中再次去访问这个不存在的成员，会触发递归操作## 3. __setattr__ 触发机制： 当给对象的成员进行赋值操作时会自动触发（包括添加，修改） 作用： 可以限制或管理对象成员的添加和修改操作 参数： 1。self 接收当前对象 2。key 设置的成员名 3。val 设置的成员值 返回值： 无 注意事项：在当前的魔术方法中禁止给当前对象的成员直接进行赋值操作，会触发递归操作 如果想要给当前对象的成员进行赋值，需要借助 object 格式： object.__setattr__(self,key,value)## 4. __delattr__ 触发机制： 当删除对象成员时自动触发 作用： 可以去限制对象成员的删除，还可以删除不存在成员时防止报错 参数：1，self 接收当前对象 2。item 删除的成员名称 返回值： 无 注意事项： 在当前魔术方法中禁止直接删除对象的成员，会触发递归操作。 如果想要删除当前对象的成员，那么需要借助 object 格式： object.__delattr__(self,item) 访问成员的顺序！！！ 调用 __getattribute__魔术方法 调用数据描述符【后面会讲】 调用当前对象的成员 调用当前类的成员 调用非数据描述符【后面会讲】 调用父类的成员 调用__getattr__魔术方法 以上步骤时调用某个成员时的顺序，前面的能够调用成功，后面则不在执行 面向对象高阶-描述符与设计模式描述符 当一个类中，包含了三个魔术方法(__get__,__set__,__delete__)之一，或者全部时，那么这个类就称为描述符类 作用 描述符的作用就是对一个类中的某个成员进行一个详细的管理操作（获取，赋值，删除）描述符就是代理了一个类中的成员的操作，描述符属于类，只能定义为类的属性 三个魔术方法1234567891011121314151617181920&#x27;&#x27;&#x27;__get__(self, instance, owner) 触发机制：在访问对象成员属性时自动触发(当该成员已经交给描述符管理时) 作用：设置当前属性获取的值 参数：1. self 描述符对象 2.被管理成员的类的对象。3.被管理成员的类 返回值：返回值作为成员属性获取的值 注意事项：无__set__(self, instance, value) 触发机制：在设置对象成员属性时自动触发(当该成员已经交给描述符管理时) 作用：对成员的赋值进行管理 参数：1. self 描述符对象 2.被管理成员的类的对象。3.要设置的值 返回值：无 注意事项：无__delete__(self, instance) 触发机制：在删除对象成员属性时自动触发(当该成员已经交给描述符管理时) 作用：对成员属性的删除进行管理 参数：1. self 描述符对象 2.被管理成员的类的对象。 返回值：无 注意事项：无&#x27;&#x27;&#x27; 数据描述符：（完整） 同时具备三个魔术方法的类就是 数据描述符 非数据描述符：（不完整） 没有同时具备三个魔术方法的类就是 非描述符类 基本使用格式 把当前的描述符类赋值给一个需要代理的类中的成员属性 代码示例： 12345678910111213141516171819202122232425262728293031# 定义描述符类class PersonName(): __name = &#x27;abc&#x27; def __get__(self, instance, owner): # print(self,instance,owner) return self.__name def __set__(self, instance, value): # print(self,instance,value) self.__name = value def __delete__(self, instance): # print(self,instance) # del self.__name print(&#x27;不允许删除&#x27;)# 定义的普通类class Person(): # 把类中的一个成员属性交给一个描述符类来实现 # 一个类中的成员的值是另一个描述符类的对象() # 那么当对这个类中得成员进行操作时，可以理解为就是对另一个对象的操作 name = PersonName()# 实例化对象zs = Person()print(zs.name)zs.name = &#x27;rs&#x27;print(zs.name)del zs.nameprint(zs.name) 描述符应用解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#定义一个学生类，需要记录 学员的id，名字，分数class Student(): def __init__(self,id,name,score): self.id = id self.name = name self.score = score def returnMe(self): info = f&#x27;&#x27;&#x27; 学员编号:&#123;self.id&#125; 学员姓名:&#123;self.name&#125; 学员分数:&#123;self.score&#125; &#x27;&#x27;&#x27; print(info)&#x27;&#x27;&#x27;# 要求：学员的分数只能在0-100范围中解决方法： 1。在__init__方法中检测当前分数范围 # 检测分数范围 if score &gt;= 0 and score &lt;= 100: self.score = score 这个解决方案只能在对象初始化时有效。 2。 定义一个setattr魔术方法检测 检测如果给score分数进行赋值时，进行分数的检测判断 def __setattr__(self, key, value): # 检测是否是给score进行赋值操作 if key == &#x27;score&#x27;: # 检测分数范围 if value &gt;= 0 and value &lt;= 100: object.__setattr__(self, key, value) else: print(&#x27;当前分数不符合要求&#x27;) else: object.__setattr__(self,key,value) 假如 学员的分数不止一个时怎么办，比如 语文分数，数学分数，英语分数 另外就是当前这个类中的代码是否就比较多了呢？ 3。可以思考使用描述符来代理我们的分数这个属性 1.定义Score描述符类 2.把学生类中的score这个成员交给描述符类进行代理 3.只要在代理的描述符类中对分数进行赋值和获取就ok了&#x27;&#x27;&#x27;#定义描述符类 代理分数的管理class Score(): def __get__(self, instance, owner): return self.__score def __set__(self, instance, value): if value &gt;= 0 and value &lt;= 100: self.__score = value else: print(&#x27;分数不符合要求&#x27;)# 使用描述符类代理score分数属性class Student(): score = Score() def __init__(self,id,name,score): self.id = id self.name = name self.score = score def returnMe(self): info = f&#x27;&#x27;&#x27; 学员编号:&#123;self.id&#125; 学员姓名:&#123;self.name&#125; 学员分数:&#123;self.score&#125; &#x27;&#x27;&#x27; print(info)# 实例化对象zs = Student(1011,&#x27;rs&#x27;,99)zs.returnMe()zs.score = -20zs.score = 88zs.returnMe() 描述符的三种定义格式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 格式一 通过定义 描述符类来实现 推荐&#x27;&#x27;&#x27;class ScoreManage(): def __get__(self, instance, owner): pass def __set__(self, instance, value): pass def __delete__(self, instance): passclass Student(): score = ScoreManage()&#x27;&#x27;&#x27;# 格式二， 使用 property 函数 来实现&#x27;&#x27;&#x27;class Student(): # 在当前需要被管理的类中 直接定义类似下面三个方法 def getscore(self): print(&#x27;getscore&#x27;) def setscore(self,value): print(&#x27;setscore&#x27;,value) def delscore(self): print(&#x27;delscore&#x27;) # 在 property 函数中指定对应的三个方法,对应的方法 1。__get__，2。__set__,3。__delete__ score = property(getscore,setscore,delscore)zs = Student()# print(zs.score)# zs.score = 200# del zs.score&#x27;&#x27;&#x27;# 格式三 使用 @property 装饰器语法来实现&#x27;&#x27;&#x27;class Student(): __score = None @property def score(self): print(&#x27;get&#x27;) return self.__score @score.setter def score(self,value): print(&#x27;set&#x27;) self.__score = value @score.deleter def score(self): print(&#x27;delete&#x27;) del self.__scorezs = Student()# print(zs.score)zs.score = 199print(zs.score)del zs.score&#x27;&#x27;&#x27; 设计模式 设计模式是前人为完成某个功能或需求，根据经验和总结，对实现的代码步骤和代码设计进行了总结和归纳，成为了实现某个需求的经典模式。 设计模式并不是固定的代码格式，而是一种面向对象编程的设计 单例(单态)设计模式 在当前脚本中，同一个类只能创建出一个对象去使用。这种情况就成为单例(单态)。 12345678910111213141516171819202122232425262728293031323334353637383940414243&#x27;&#x27;&#x27;实现单例的案例，思考：单例和婚姻法的关系，特别像，一个人只能有一个结婚对象在社会中是如何完成一夫一妻制的？如果要结婚，必须要到 民政局 登记民政局 需要检测两个人的户口本，看上面是否属于 结婚的状态如果是已婚，肯定就撵出去了。如果没有结婚，可以给盖个章了，开始登记。那么按照这样的思路如何去实现 python中的单例设计模式呢？1。需要有一个方法，可以去控制当前对象的创建过程？ 构造方法 __new__2。需要有一个标示来存储和表示是否有对象 创建一个私有属性 进行存储，默认值为None3。在创建对象的方法中去检测和判断是否有对象？ 如果没有对象，则创建对象，并且把对象存储起来，返回对象 如果存储的是对象，则直接返回对象，就不需要创建新的对象了&#x27;&#x27;&#x27;class Demo(): # 2.定义私有属性存储对象，默认值为None __obj = None # 1.定义构造方法 def __new__(cls, *args, **kwargs): # 3。在创建对象的过程中，判断是否有对象 if not cls.__obj: # 判断如果没有对象，则创建对象，并且存储起来 cls.__obj = object.__new__(cls) # 直接把存储的对象返回 return cls.__obj# 实例化对象a = Demo()b = Demo()print(a)print(b)&#x27;&#x27;&#x27;&lt;__main__.Demo object at 0x106f4d850&gt;&lt;__main__.Demo object at 0x106f4d850&gt;&#x27;&#x27;&#x27; Mixin 混合设计模式Mixin类 Mixin 必须是表示一种功能，而不是一个对象。 Mixin 的功能必须单一，如果有多个功能，那就多定义Mixin类 python 中的Mixin是通过多继承实现的 Mixin 这个类通常不单独使用，而是混合到其它类中，去增加功能的 Mixin 类不依赖子类的实现，即便子类没有继承这个Mixin,子类也能正常运行，可能就是缺少了一些功能。。 使用Mixin混入类的好处？ Mixin 这个混入类的设计模式，在不对类的内容修改的前提下，扩展了类的功能 Mixin 混入类为了提高代码的重用性，使得代码结构更加简单清晰 可以根据开发需要任意调整功能（创建新的Mixin混入类）避免设计多层次的复杂的继承关系。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#x27;&#x27;&#x27;继承需要有一个必要的前提，继承应该是一个 &#x27;is-a&#x27; 的关系例如： 苹果可以去继承水果，因为苹果就是一个水果 苹果不能继承午饭，因为午饭可以有苹果也可以没有 比如 汽车可以继承 交通工具，因为汽车本身就是一个交通工具交通工具有哪些？汽车，飞机，直升机，这些都属于 交通工具那么如何去设计这些类的关系呢？比如创建一个交通工具类，然后属于交通工具的都来继承，再去实现。。。但是，飞机和直升机都有飞行的功能，而汽车并没有，那么在交通工具中如果去定义 飞行这个功能，那就不太合适了。。能不能在飞机和直升机类中分别实现 飞行 这个功能呢？可以，但是代码又无法重用。怎么办？单独去定义交通工具类，和 飞行器 这个两个父类，这样飞机和直升机就可以去继承这两个类.&#x27;&#x27;&#x27;# 交通工具 vehicleclass vehicle(): # 运输货物 def transmit(self): print(&#x27;transmit goods&#x27;) # 搭载乘客 def carry(self): print(&#x27;Carrying passengers&#x27;)# 飞行器class FlyingMixin(): def fly(self): print(&#x27;fly...&#x27;)# 定义汽车类class cart(vehicle): pass# 定义飞机class airplane(vehicle,FlyingMixin): pass# 定义直升机class helicopter(vehicle,FlyingMixin): pass# 此时去定义一个飞行器的类 Flying，让需要飞行的交通工具，直接继承这个类。可以解决这个问题。# 但是，1。出现类多继承，违背了&#x27;is-a&#x27; 2。飞行器这个类很容易被误解# 解决方案也是使用多继承，但是给飞行器这个类，定义成为一个 Mixin 混合类,# 此时就是等于把飞行器这个类，作为了一个扩展的功能，来扩展其它类&#x27;&#x27;&#x27;在上面的代码中，虽然直升机和飞机都使用了多继承，也就是继承了FlyingMixin但是由于 FlyingMixin 类加了 Minin这个名，就告诉了后面阅读代码的人，这个类是一个Mixin类&#x27;&#x27;&#x27; 抽象类（了解） 1234抽象类是一个特殊的类： 1. 抽象类不能用，不能直接实例化成为一个对象。 2. 抽象类中包含了抽象方法，抽象方法就是没有实现代码的方法。 3. 抽象类需要子类继承，并重写父类的抽象方法。才可以使用。 12345678抽象类，一般应用在程序设计，程序设计中一般是要对功能和需求进行规划，其中有一些需求是明确的并且可以完成的，但是也可能会有一些需求是不明确的，或者不确定具体需要怎么实现，那么此时就可以把这个不确定怎么实现或者需要后面再去实现的方法，定义为抽象方法（只定义方法名，不写具体代码）抽象类的应用： 例如要开发一个框架，这个框架要有一些基本功能和扩展功能。。。。 但是你具体用这个框架开发什么样的产品，开发框架的人并不清楚或者确定。 因此框架就具备一定的功能，并且留下来一些方法的定义，剩下的就是需要自己在方法中具体实现自己业务逻辑。 抽象类的定义： 123456789101112131415161718192021222324252627282930313233import abc# 如果要定义为抽象类，那么这个类的 metaclass属性必须是 metaclass=abc.ABCMetaclass WriteCode(metaclass=abc.ABCMeta): #需要抽象的方法，使用装饰器进行装饰 @abc.abstractmethod def write_php(self): pass def write_java(self): print(&#x27;实现了java代码的开发&#x27;) def write_python(self): print(&#x27;实现了python代码的开发&#x27;)# 抽象类不能直接实例化对象# obj = WriteCode()# print(obj)#TypeError: Can&#x27;t instantiate abstract class WriteCode with abstract methods write_php# 定义子类，继承抽象类，并实现抽象类中的抽象方法class Demo(WriteCode): def write_php(self): print(&#x27;实现了php代码的开发&#x27;)a = Demo()print(a)a.write_java()a.write_php()a.write_python() 装饰器 decorator装饰器定义在不改变原有函数代码，且保持原函数调用方法不变的情况下，给原函数增加新的功能(或者给类增加属性和方法)核心思想：用一个函数（或者类）去装饰一个旧函数（或者类），造出一个新函数（或者新类）应用场景：引入日志，函数执行时间的统计，执行函数前的准备工作，执行函数后的处理工作，权限校验，缓存等语法规则：在原有的函数上加上 @符，装饰器会把下面的函数当作参数传递到装饰器中，@符又被成为 语法糖 1.装饰器原型（闭包）1234567891011121314151617181920212223242526# 1。 装饰器的原型### 利用闭包，把函数当作参数传递，并且在函数内去调用传递进来的函数，并返回一个函数# 定义外函数，接收一个函数作为参数def outer(f): # 定义内函数，并且在内函数中调用了外函数的参数 def inner(): print(&#x27;我是外函数中的内函数1&#x27;) f() print(&#x27;我是外函数中的内函数2&#x27;) return inner# 定义普通函数# def old():# print(&#x27;我是一个普通的函数&#x27;)## # old() # 作为普通函数直接调用# old = outer(old) # outer返回了inner函数，赋值给了old# old() # 此时再调用old函数时，等同于调用了 inner 函数# 改为装饰器用法@outer # 此处使用的@outer的语法就是把outer作为了装饰器，等同于 old = outer(old)def old(): print(&#x27;我是一个普通的函数&#x27;)old() # old函数经过 outer装饰器进行了装饰，代码和调用方法不变，但是函数的功能发送了改变 2.装饰器的应用：统计函数的执行时间1234567891011121314151617181920# 装饰器应用场景-统计函数执行时间import time# 定义一个统计函数执行时间的 装饰器def runtime(f): def inner(): start = time.perf_counter() f() end = time.perf_counter() - start print(f&#x27;函数的调用执行时间为：&#123;end&#125;&#x27;) return inner# 定义一个函数@runtimedef func(): for i in range(5): print(i,end=&quot; &quot;) time.sleep(1)func() 3.装饰器嵌套语法12345678910111213141516171819202122232425262728293031323334353637383940# 1.定义装饰器# 外函数def outer(func): #内函数 def inner(): print(&#x27;this is 3&#x27;) func() # 在内函数中调用外函数中的行参-函数 print(&#x27;this is 4&#x27;) # 在外函数中返回内函数 return inner# 2。在定义一个装饰器def extend(f): def kzinner(): print(&#x27;extend1&#x27;) f() print(&#x27;extend2&#x27;) return kzinner# 3. 装饰器的嵌套 先执行下面的，再执行上面的。@extend # 2。再使用上面的extend 装饰器，装饰 上一次返回的 inner 函数，又返回了 kzinner 函数@outer # 1。先使用离得近的 outer装饰器 装饰love函数，返回了一个 inner函数def test(): print(&#x27;this is test... 5&#x27;)test()&#x27;&#x27;&#x27; 结果和过程的解析1 3 5 4 21 先使用离得近的 outer装饰器 装饰test函数，返回了一个 inner函数2 再使用上面的 extend 装饰器，装饰 上一次返回的 inner 函数，又返回了 kzinner 函数最后在调用test函数的时候是怎么执行的 test() == kzinner() ===&gt; 1 ===&gt; inner() ===&gt; 3 ===&gt; test() ===&gt; 5 ===&gt; 4 ===&gt; 2&#x27;&#x27;&#x27; 4.对带有参数的函数进行装饰12345678910111213141516# 定义装饰器def outer(func): # 如果装饰器带有参数的函数，需要在内函数中定义行参，并传递给调用的函数。因为调用原函数等于调用内函数 def inner(var): print(f&#x27;&#123;var&#125; this is 1&#x27;) func(var) print(f&#x27;&#123;var&#125; this is 3&#x27;) return inner# 有参数的函数@outerdef test(name): print(f&#x27;&#123;name&#125; this is test func...&#x27;)test(&#x27;ycr&#x27;) #test() ==&gt; inner() test(&#x27;ycr&#x27;) ===&gt; inner(&#x27;ycr&#x27;) 5.对多参数的函数进行装饰12345678910111213141516171819202122# 装饰带有多参数的函数def outer(func): def inner(who,name,*args,**kwargs): print(&#x27;this is 1...&#x27;) func(who,name,*args,**kwargs) print(&#x27;this is 3...&#x27;) return inner# 定义多参数的 函数@outerdef test(age,name,*args,**kwargs): print(f&#x27;age: &#123;age&#125;, name: &#123;name&#125;&#x27;) print(&#x27;show args: &#x27;,args) print(&#x27;show kwargs&#x27;,kwargs)test(&#x27;22&#x27;,&#x27;ycr&#x27;,&#x27;aa&#x27;,&#x27;bb&#x27;,&#x27;cc&#x27;, k = &#x27;A&#x27;)&#x27;&#x27;&#x27;test() ==&gt; inner() test(...) ==&gt; inner(...) inner(...) ==&gt; test(...)&#x27;&#x27;&#x27; 6.带有参数的装饰器 你会遇到带有参数的装饰器，例如Django框架中的 @login_required(login_url=’/accounts/login/‘) 12345678910111213141516171819202122# 如果你的装饰器需要有参数，那么给当前的装饰器套一个壳，用于接收装饰器的参数def extend(var): def outer(func): def inner1(): print(&#x27;hello&#x27;) func() def inner2(): print(&#x27;world&#x27;) func() # 装饰器壳的参数，可以用于在函数内去做流程控制 if var == 1: return inner1 else: return inner2 return outer@extend(2) # extend(var) ==&gt; outer() ==&gt; outer(test) ==&gt; inner()def test(): print(&#x27;this is test function&#x27;)test() 7.用类装饰器装饰函数12345678910111213141516171819# 类装饰器装饰函数class Outer(): # 魔术方法：当把该类的对象当作函数调用时，自动触发 obj() def __call__(self,func): self.func = func # 把传进来的函数作为对象的成员方法 return self.inner # 返回一个函数 # 在定义的需要返回的新方法中 去进行装饰和处理 def inner(self,who): print(&#x27;hello&#x27;) self.func(who) print(&#x27;world&#x27;)@Outer() # Outer() ==&gt; obj @obj==&gt;obj(love) ==&gt; __call__(love) ==&gt; inner()def test(who): print(f&#x27;&#123;who&#125; , this is test function&#x27;)test(&#x27;rs&#x27;) # inner(&#x27;rs&#x27;)print(test) # 此时的 test就是属于Outer类这个对象中的inner方法 8.用类方法装饰函数12345678910111213141516# 用类方法装饰函数class Outer(): def newinner(func): Outer.func = func # 把传递进来的函数定义为类方法 return Outer.inner # 同时返回一个新的类方法 def inner(): print(&#x27;hello&#x27;) Outer.func() print(&#x27;world&#x27;)@Outer.newinner # Outer.newinner(test) ==&gt; Outer.innerdef test(): print(&#x27;this is test function&#x27;)test() # test() ==&gt; Outer.inner() 到目前为止以上所以形式的装饰器，包括 函数装饰器，类装饰器，类方法装饰器，都有一个共同特点：都是在给函数去进行装饰，增加功能。 用装饰器装饰类 还有一种装饰器，是专门装饰类的。也就是在类的定义的前面使用@装饰器这种语法@装饰器class Demo():pass 装饰器给函数进行装饰，目的是不改变函数调用和代码的情况下给原函数增加了新的功能。 装饰器给类进行装饰，目的是不改变类的定义和调用的情况下给类增加新的成员（属性或方法）。 9.用函数装饰器装饰类123456789101112131415161718192021# 使用函数装饰器，给类进行装饰，增加新的属性和方法# 定义函数，接收一个类。返回修改后的类def kuozhan(cls): def func2(): print(&#x27;我是在装饰器中追加的新方法，func2&#x27;) cls.func2 = func2 # 把刚才定义的方法赋值给 类 cls.name = &#x27;我是在装饰器中追加的新属性 name&#x27; #返回时，把追加类新成员的 类 返回去 return cls@kuozhan # kuozhan(Demo) ==&gt; cls ==&gt; Democlass Demo(): def func(): print(&#x27;我是Demo类中定义的func方法&#x27;)Demo.func() # 此时在调用的Demo类是通过装饰器，更新过的Demo类Demo.func2()print(Demo.name) 10.使用类装饰器装饰类123456789101112131415161718192021222324252627282930class extend(): def __call__(self, cls): # 把接收的类，赋值给当前对象，作为一个属性 self.cls = cls # 返回一个函数 return self.newfunc def newfunc(self): self.cls.name = &#x27;我是在类装饰器中追加的新属性 name&#x27; self.cls.func2 = self.func2 # 返回传递进来的类的实例化结果，obj return self.cls() def func2(self): print(&#x27;我是在类装饰器中追加的新方法 func2&#x27;)@extend() # extend() ==&gt; obj ==&gt; @obj(Demo) ==&gt; __call__(Demo) ==&gt; newfuncclass Demo(): def func(self): print(&#x27;我是Demo类中定义的func方法&#x27;)obj = Demo() # Demo() ==&gt; newfunc() ==&gt; objobj.func()obj.func2()print(obj.name)# 思考： 此时的 obj这个对象，是哪个类的对象。Demo还是extendprint(obj) # 此时的obj依然是Demo类的实例化对象，只不过经过装饰后，增加了新的属性和方法","categories":[{"name":"Python","slug":"Python","permalink":"https://rscuber.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://rscuber.github.io/tags/Python/"},{"name":"基础入门","slug":"基础入门","permalink":"https://rscuber.github.io/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]},{"title":"Python模块化编程","slug":"python模块化编程","date":"2021-11-21T02:50:02.000Z","updated":"2021-12-21T08:06:17.592Z","comments":true,"path":"archives/76c330d3.html","link":"","permalink":"https://rscuber.github.io/archives/76c330d3.html","excerpt":"模块化编程 模块化编程指把程序进行封装(函数封装，面向对象，文件。。。)","text":"模块化编程 模块化编程指把程序进行封装(函数封装，面向对象，文件。。。) 函数什么是函数？ function -&gt; 函数，功能 函数就是一个具有特定功能的代码块 函数的作用？ 函数就是把代码进行封装，以提高代码的重用性，提高开发效率，并且降低了后期的维护成本 函数的定义和使用1234567891011# 定义函数【基本结构】def 函数名([参数列表]): 当前函数的具体功能的代码 当前函数的具体功能的代码 。。。。 # 函数封装完并不会执行，只是把函数定义了而已# 如果想使用定义的函数，那么就需要用语法来进行函数的调用# 函数的调用函数名() 函数的特征及注意事项 函数定义后，不调用不执行 不能在函数定义前调用函数 函数的调用不受次数影响 函数的命名要遵守命名规范 字母数字下划线，不能以数字开头 严格区分大小写，不能使用关键字 命名最好有意义，且不要使用中文 函数名不要冲突，冲突后会被覆盖 关于函数的参数 函数在定义时,可以在参数列表的位置定义形参 如果函数有形参,那么在函数调用时也需要给定参数 实参将值传递给形参的过程，本质上就是变量赋值操作 (1)函数参数概念及分类1234567函数参数:调用时需要传递的数据.函数参数大类分为形参和实参:. 形参意思: 函数定义时的参数. 实参意思: 函数调用时的参数形实关系:函数调用时,形参和实参个数需要一一对应形参种类: 普通参数,默认参数,普通收集参数,命名关键字参数,关键字收集参数实参种类: 普通实参,关键字实参 (2)普通参数（位置参数）普通的参数，接收实参传递的值 (3)默认参数： 位于普通参数后面，具有默认值的参数 语法：(x,y=2) y就是默认参数 (4)收集参数: 专门收集在函数调用时传递的多余的实参 123451.普通收集参数:专门用于收集多余的普通参数,形成一个新的元组 语法:参数前面加* 例:*args2.关键字收集参数:用于专门收集多余关键字实参,形成一个新的字典 语法:参数前面加** 例:**kwargs 实例 123456789101112131415161718192021222324def calc(comp, *args): for i in range(len(args)): i and print(comp, end = &#x27; &#x27;) print(args[i], end = &#x27; &#x27;) ans = args[0] if comp == &#x27;+&#x27;: for i in range(1, len(args)): ans += args[i] elif comp == &#x27;-&#x27;: for i in range(1, len(args)): ans -= args[i] elif comp == &#x27;*&#x27;: for i in range(1, len(args)): ans *= args[i] else: for i in range(1, len(args)): ans /= args[i] print(&#x27;=&#x27;, ans) return calc(&#x27;+&#x27;, 1, 2, 3, 4, 5)calc(&#x27;-&#x27;, 100, 1, 2, 3, 4, 5)calc(&#x27;*&#x27;, 1, 2, 3, 4, 5)calc(&#x27;/&#x27;, 100, 2, 5, 1.25) 执行结果： 12341 + 2 + 3 + 4 + 5 = 15100 - 1 - 2 - 3 - 4 - 5 = 851 * 2 * 3 * 4 * 5 = 120100 / 2 / 5 / 1.25 = 8.0 (5)命名关键字参数 定义时放在*号后面的参数,调用时强制必须传入指定参数名才能调用 123语法:(a,*,x) x是命名关键字参数如果函数参数中已经有了收集参数，那么收集参数后面的参数即为命名关键字参数 语法:(*args,x,y) (6)形参声明的位置顺序: 普通参数 -&gt; 默认参数 -&gt; 收集参数 -&gt; 命名关键字参数 -&gt; 关键字收集参数 1234def func(a,b,c=1,*args,d,**kw)a,b为普通参数，c是默认参数，args是收集参数，d是命名关键字参数，kw是关键字收集参数极少出现五种参数同时出现的情况 所有参数的摆放问题 实参：普通实参在前，关键字参数在后 形参： 关键字收集参数一定在最后出现 收集参数推荐在普通参数之后使用 推荐顺序：普通形参,收集参数,关键字收集参数 实例 123456789def prtArgs(a, b, c = 3, *args, name, age, **kwargs): print(&#x27;普通参数:&#x27;, type(a), a, b) print(&#x27;默认参数:&#x27;, type(c), c) print(&#x27;收集参数:&#x27;, type(args), args) print(&#x27;关键字参数:&#x27;, type(name), name, age) print(&#x27;收集关键字参数:&#x27;, type(kwargs), kwargs) return prtArgs(1, 3.14, 123, &#x27;a&#x27;, &#x27;b&#x27;, name = &#x27;ycr&#x27;, age = 22, k1 = &#x27;A&#x27;, k2 = &#x27;B&#x27;) 执行结果： 12345普通参数: &lt;class &#x27;int&#x27;&gt; 1 3.14默认参数: &lt;class &#x27;int&#x27;&gt; 123收集参数: &lt;class &#x27;tuple&#x27;&gt; (&#x27;a&#x27;, &#x27;b&#x27;)关键字参数: &lt;class &#x27;str&#x27;&gt; ycr 22收集关键字参数: &lt;class &#x27;dict&#x27;&gt; &#123;&#x27;k1&#x27;: &#x27;A&#x27;, &#x27;k2&#x27;: &#x27;B&#x27;&#125; 函数返回值 一个函数除来可以完成一定功能之外，还可以按需要返回一些内容 函数中使用 return 关键字来指定返回数据，可以返回任意类型的数据 函数的返回值，会把数据返回到调用处，可以使用变量接收，或其它处理 123函数可以分为两类 1。执行过程函数： 函数体内完成一定的功能既可，没有返回值 2。具有返回值的函数： 函数体内完成一定的功能，并且返回一个结果到函数调用处 return返回值的特征 函数中可以使用 return 进行数据的返回 可以使用return 返回 任意内容或数据 return 会把返回值，返回到函数调用出 return 意味着函数的结束，return之后的代码不在执行 如果在函数中没有使用return 或者 return后面没有任何内容，那么默认返回 None 12345678910111213# 假设有这样一个需求，定义一个函数，完成两个数的计算，并把结果输出# def add(n1,n2):# res = n1+n2# print(res)# add(2,5)# 需求改变，定义一个函数，完成两个数的计算，并把结果返回def add(n1,n2): res = n1+n2 return resr = add(2,4)print(r) 变量作用域 作用域就是当前起作用，可用的范围区域 变量的有效范围 全局变量：在函数内外都可以使用的变量 局部变量：只在函数内部可以使用的变量 123456789101112131415局部变量 函数内定义的变量，局部变量，在函数外不能使用全局变量 在函数内部使用 global 直接定义的变量，就是全局变量，函数内外都可以使用 在函数外定义的变量，在函数内使用 global 关键字进行声明，就会变成全局变量globals() 获取全局数据locals() 获取当前作用域的数据在函数外定义的变量，函数可以访问，但是不能更改(不可变数据类型)数据类型的分类： 可变数据类型：在函数外定义的变量，在函数可以使用 -&gt; 列表和字典 不可变数据类型：在函数外定义的变量，在函数内只能访问，不能使用其它操作 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445num = 1varlist = [1, 2, 3]vardict = &#123;&#x27;a&#x27;: 11, &#x27;b&#x27;: 22, &#x27;c&#x27;: 33&#125;def test1(): print(&quot;test1: num =&quot;, num) # num += 1 错误 # 在函数外定义的变量，函数可以访问，但是不能更改(不可变数据类型) return def test2(): # 可变数据类型：在函数外定义的变量，在函数可以使用 -&gt; 列表和字典 varlist[0] = 123 vardict[&#x27;a&#x27;] = 111 print(&quot;test2: varlist =&quot;, varlist) print(&quot;vardict =&quot;, vardict) return def test3(): # 在函数外定义的变量，在函数内使用 global 关键字进行声明，就会变成全局变量 global num num += 1 print(&quot;test3: num =&quot;, num) return def test4(): # 在函数内部使用 global 直接定义的变量，就是全局变量，函数内外都可以使用 global a a = 10 return def test5(): b = 1 print(globals()) # 获取全局数据 print(locals()) # 获取当前作用域的数据 return test1()test2()test3()test4()a += 10print(&quot;test4: a =&quot;, a)print(&quot;下面的是test5:&quot;)test5() 执行结果: 12345678test1: num = 1test2: varlist = [123, 2, 3]vardict = &#123;&#x27;a&#x27;: 111, &#x27;b&#x27;: 22, &#x27;c&#x27;: 33&#125;test3: num = 2test4: a = 20下面的是test5:&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;_frozen_importlib_external.SourceFileLoader object at 0x11032eca0&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;__file__&#x27;: &#x27;/Users/rscuber/Documents/Python/Python全栈/code/nonlocal.py&#x27;, &#x27;__cached__&#x27;: None, &#x27;num&#x27;: 2, &#x27;varlist&#x27;: [123, 2, 3], &#x27;vardict&#x27;: &#123;&#x27;a&#x27;: 111, &#x27;b&#x27;: 22, &#x27;c&#x27;: 33&#125;, &#x27;test1&#x27;: &lt;function test1 at 0x11037a0d0&gt;, &#x27;test2&#x27;: &lt;function test2 at 0x1104afd30&gt;, &#x27;test3&#x27;: &lt;function test3 at 0x110417310&gt;, &#x27;test4&#x27;: &lt;function test4 at 0x1104175e0&gt;, &#x27;test5&#x27;: &lt;function test5 at 0x110417670&gt;, &#x27;a&#x27;: 20&#125;&#123;&#x27;b&#x27;: 1&#125; 不光变量有作用域，函数一样也有相同的作用域123456789def outer(): print(&#x27;this is outer function...&#x27;) # 在函数内定义的函数，称为 局部函数，函数外无法使用 def inner(): print(&#x27;this is inner function...&#x27;) inner()outer()# inner() ❌ nonlocal 在内函数中如何使用上一层函数中的局部变量？在内函数中如果想使用外层函数的变量，那么需要使用 nonlocal 关键字 引用可以引用上一层函数中定义的局部变量，但依然不能提升为全局变量 1234567891011121314# 定义一个外层函数def outer(): # 外函数的局部变量 num = 10 # 内函数，局部函数，在函数的内部定义的函数 def inner(): # nonlocal 关键字在局部函数中使用， nonlocal num # 可以引用上一层函数中定义的局部变量，但依然不能提升为全局变量 num += 1 print(num) inner()outer()# print(num) ❌ 关于函数的文档123456789101112131415161718192021222324252627282930313233def outer(): &#x27;&#x27;&#x27; 这里是让你些当前函数的文档说明的。 需要说明当前函数的作用， 如果当前函数还有行参，那么也需要对行参进行一一说明 name： 这个是一个name参数，有什么作用。。。 age ： 这个表示当前的一个年龄 :return: 此处说明当前函数的返回值。。。 &#x27;&#x27;&#x27;print(globals())print(__name__) # 获取当前脚本的文件名，print(__doc__) # 获取当前脚本的说明文档print(outer.__doc__) # 获取当前函数的说明文档&#x27;&#x27;&#x27;魔术变量__name__ ==&gt; 当前脚本如果作为主程序，那么值是 __main__,如果是当做一个模块，在另外一个脚本中引用去使用，那么值就是当前文件的名字__doc__ ==&gt; 当前脚本的文档说明 在当前脚本当中的第一个 三引号注释就是当前脚本的说明文档&#123; &#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: &#x27;\\n在内函数中如果想使用外层函数的变&#x27;, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;_frozen_importlib_external.SourceFileLoader object at 0x110444350&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;__file__&#x27;: &#x27;/Users/yc/Desktop/code/8.nonlocal关键字.py&#x27;, &#x27;__cached__&#x27;: None, &#x27;outer&#x27;: &lt;function outer at 0x1104938c0&gt;&#125;&#x27;&#x27;&#x27; 函数封装的练习题123456789101112131415161718192021222324252627282930313233def mul(n = 1): for i in range(1, n + 1): for j in range(1, i + 1): print(f&#x27;&#123;i&#125; * &#123;j&#125; = &#123;i * j&#125;&#x27;, end = &#x27; &#x27;) print() return mul(5)print()def rectangle(n = 1): &#x27;&#x27;&#x27; n = 0为空心, n = 1为实心 &#x27;&#x27;&#x27; if n == 1: for i in range(1, 101): print(&#x27;#&#x27;, end = &#x27; &#x27;) if i % 10 == 0: print() else: for i in range(10): for j in range(10): if i == 0 or i == 9 or j == 0 or j == 9: print(&#x27;#&#x27;, end = &#x27; &#x27;) else: print(&#x27; &#x27;, end = &#x27; &#x27;) print() return print(rectangle.__doc__)rectangle(0)print()rectangle() 执行结果: 1234567891011121314151617181920212223242526272829301 * 1 = 1 2 * 1 = 2 2 * 2 = 4 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 5 * 1 = 5 5 * 2 = 10 5 * 3 = 15 5 * 4 = 20 5 * 5 = 25 n = 0为空心, n = 1为实心 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 高阶函数递归函数 递归函数就是定义了一个函数，然后在函数内，自己调用了自己这个函数递归函数内必须要有结束，不然就会一只调用下去，直到调用的层数越来越多，栈溢出递归函数是一层一层的进入，再一层一层的返回 初步认识递归函数1234567891011121314def fibonacci(n): # 斐波那契数列 if n == 1 or n == 2: return 1 else: return fibonacci(n - 1) + fibonacci(n - 2)def factorial(n): # 阶乘 if n == 0 or n == 1: return 1 else: return factorial(n - 1) * nprint(fibonacci(5))print(factorial(5)) 执行结果: 125120 回调函数 函数中的参数可以是任意类型的，那参数能不能是一个函数呢？ 如果在一个函数中要求传递的参数是一个函数作为参数，并且在函数中使用了传递进来的函数，那么这个函数我们就可以称为是一个回调函数 12345678910111213# 定义一个函数,函数中的一个参数要求是另一个函数# 带有回调函数参数的函数def func(a, b, f): print(f, type(f)) print(&quot;&#123;&#125; + &#123;&#125; = &#123;&#125;&quot;.format(a, b, f(a, b))) # 并且在函数中调用了传递进来的行参函数 return # 回调函数def add(a, b): return a + bfunc(1, 2, add) 执行结果: 12&lt;function add at 0x109db1d30&gt; &lt;class &#x27;function&#x27;&gt;1 + 2 = 3 闭包函数 既然可以把函数作为一个行参进行传递，作为回调函数，那么如果在一个函数中，返回了一个函数呢？ 在一个函数内返回了一个内函数， 并且这个返回的内函数还使用了外函数中局部变量，这就是闭包函数 特点： 在外函数中定义了局部变量，并且在内部函数中使用了这个局部变量 在外函数中返回了内函数，返回的内函数就是闭包函数 ⚠主要在于保护了外函数中的局部变量，既可以被使用，又不会被破坏 检测一个函数是否为闭包函数，可以使用 函数名.__closure__如果是闭包函数返回 cell 12345678910111213141516171819# 定义一个函数def person(): money = 0 # 函数中定义了一个局部变量 # 工作 定义的内函数 def work(): nonlocal money # 在内函数中使用了外函数的临时变量 money += 100 print(money) # 在外函数中返回了内函数，这个内函数就是闭包函数 return workres = person() # return work res = workres() # res() == work()res()res()print(res.__closure__)print(person.__closure__)# 此时 就不能够在全局中对money这个局部变量进行任何操作了，# 闭包的作用：保护了函数中的变量不受外部的影响，但是又能够不影响使用 执行结果： 12345100200300(&lt;cell at 0x100b37fd0: int object at 0x100a8a430&gt;,)None 匿名函数 lambda 表达式 匿名函数的意思就是说可以不使用def定义，并且这个函数也没有名字 在python中可以使用lambda表达式来定义匿名函数 注意：lambda表达式仅仅是一个表达式，不是一个代码块，所以lambda又称为一行代码的函数 lambda表达式也有行参，并且不能访问除了自己的行参之外的任何数据包括全局变量 1234567891011121314151617181920212223&#x27;&#x27;&#x27;语法：lambda [参数列表]:返回值&#x27;&#x27;&#x27;# 封装一个函数做加法运算# 普通函数def add(x, y): return x + yprint(add(2, 3))# 改成lambda表达式来封装res = lambda x, y : x + yprint(res(3, 5))# 带有分支结构的lambda 表达式# lambda 参数列表: 真区间 if 表达式判断 else 假区间res = lambda ch : &quot;Yes!&quot; if ch == &#x27;y&#x27; else &quot;No!&quot;print(res(&#x27;y&#x27;))res = lambda x, y : f&#x27;&#123;x&#125; &gt; &#123;y&#125;&#x27; if x &gt; y else f&#x27;&#123;x&#125; &lt;= &#123;y&#125;&#x27;print(res(3, 6)) 执行结果： 123458Yes!3 &lt;= 6 迭代器 迭代器是python中最具特色的功能之一，是访问集合元素的一种方式 迭代器是一个可以记住访问遍历的位置的对象 从集合的第一个元素开始访问，直到集合中的所有元素被访问完毕 迭代器只能从前往后一个一个的便利，不能后退 能被next()函数调用，并不断返回下一个值的对象称为迭代器（Iterator 迭代器对象） iter() 功能：把可迭代的对象，转为一个迭代器对象参数：可迭代的对象 （str，list，tuple，dict, set, range)返回值： 迭代器对象注意：迭代器一定是一个可以迭代的对象，但是可迭代对象不一定是迭代器 next() next()函数可以去调用迭代器，并返回迭代器中的下一个数据 迭代器的取值方案 next() : 调用一次获取一次，直到数据被取完 list() : 使用list函数直接取出迭代器中的所有数据 for : 使用for循环遍历迭代器的数据 迭代器取值的特点，取出一个少一个，直到都取完，最后再获取就会报错 检测迭代器和可迭代对象的方法123456789101112from collections.abc import Iterator,Iterable varstr = &#x27;123456&#x27; res = iter(varstr) # type() 函数返回当前数据的类型， # isinstance() 检测一个数据是不是一个指定的类型 r1 = isinstance(varstr,Iterable) # True 可迭代对象 r2 = isinstance(varstr,Iterator) # False 不是一个迭代器 r3 = isinstance(res,Iterable) # True 可迭代对象 r4 = isinstance(res,Iterator) # True 是一个迭代器 # 迭代器一定是一个可迭代的对象，可迭代对象不一定是迭代器 实例1 1234567891011121314151617181920212223242526272829303132import syslist = [1, 2, 3, 4]it = iter(list)print(type(it))print(it)for i in range(len(list)): print(next(it), end = &#x27; &#x27;)print()list1 = [5, 6, 7, 8]it = iter(list1)for data in it: print(data, end = &#x27; &#x27;)print()from collections.abc import Iterable, Iteratorvarstr = &#x27;hello&#x27;# isinstance() 检测一个数据是不是一个指定的类型 print(isinstance(varstr, Iterable), isinstance(varstr, Iterator))print(isinstance(list1, Iterable), isinstance(list1, Iterator))print(isinstance(it, Iterable), isinstance(it, Iterator))list2 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]it = iter(list2)while True: try: print(next(it), end = &#x27; &#x27;) except StopIteration: print() sys.exit() 执行结果： 12345&lt;class &#x27;list_iterator&#x27;&gt;&lt;list_iterator object at 0x10aa56f10&gt;1 2 3 4 5 6 7 8 a b c d 实例2 123456789101112131415161718#自己封装一个类，使其对象可迭代class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): if self.a &lt;= 10: x = self.a self.a += 1 return x else: raise StopIterationmyclass = MyNumbers()myiter = iter(myclass)print(next(myiter))for x in myiter: print(x) 执行结果： 1234567891011112345678910 内置函数 内置函数就是在系统安装完python解释器时，由python解释器给提供好的函数 range() 函数 如果你确实需要遍历一个数字序列，内置函数 range() 会派上用场。它生成算术级数 12345678910111213# (class) range# range(stop) -&gt; range object # range(start, stop[, step]) -&gt; range object# Return an object that produces a sequence of integers from start (inclusive) to stop (exclusive) by step. range(i, j) produces i, i+1, i+2, ..., j-1. start defaults to 0, and stop is omitted! range(4) produces 0, 1, 2, 3. These are exactly the valid indices for a list of 4 elements. When step is given, it specifies the increment (or decrement).range()函数功能：能够生成一个指定的数字序列参数： start : 开始的值 ，默认值为0 stop : 结束的值 [, step] : 可选，步进值 默认值为1返回值： 可迭代的对象，数字序列 实例： 12345678910111213141516171819202122232425# range函数的使用方式# 只写一个参数，就是从零开始到10之前# res = range(11)# 两个参数时，第一个参数是开始的值，第二个参数是结束的值（在结束值之前）# res = range(5,10)# 三个参数， 参数1是开始值，参数2是结束值，参数三是步进值# res = range(1,10,3)# 获取一个倒序的数字序列# res = range(10,0,-1)# res = range(10,0,-2)res1 = range(11)res2 = range(5,10)res3 = range(1,10,3)res4 = range(10,0,-1)res5 = range(10,0,-2)print(list(res1))print(list(res2))print(list(res3))print(list(res4))print(list(res5)) 执行结果： 12345[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10][5, 6, 7, 8, 9][1, 4, 7][10, 9, 8, 7, 6, 5, 4, 3, 2, 1][10, 8, 6, 4, 2] 提取range()函数返回的数字序列的方法： 12345678910111213141516171819202122import sys# 获取range函数返回的数字序列的方法res = range(1, 6, 2)# 1. 转为list列表数据print(list(res))# 2. 通过 for循环 进行遍历for i in res: print(i, end = &#x27; &#x27;)print()# 3. 转为迭代器，使用next函数调用res = iter(res)while True: try: print(next(res), end = &#x27; &#x27;) except StopIteration: print() sys.exit() 执行结果: 123[1, 3, 5]1 3 5 1 3 5 zip() 函数1234zip()功能：zip 函数是可以接受多个可迭代的对象，然后把每个可迭代对象中的第i个元素组合在一起，形成一个新的迭代器参数：*iterables，任意个的 可迭代对象返回值： 返回一个元组的迭代器 实例 123456789101112131415161718var1 = &#x27;1234&#x27;var2 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]var3 = (&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;)# 调用zip函数，组成新的元组迭代器, 用于矩阵计算ret = zip(var1, var2, var3)print(ret, type(ret))for i in ret: print(i)# zip() 与 * 运算符相结合可以用来拆解一个列表:x = [1, 2, 3]y = [4, 5, 6]zipped = zip(x, y)print(list(zipped))print(zip(x, y)) # 迭代器对象，print(*zip(x, y))# 组合好的多个元组数据x2, y2 = zip(*zip(x, y))print(x == list(x2) and y == list(y2)) 执行结果: 12345678&lt;zip object at 0x10ec7c300&gt; &lt;class &#x27;zip&#x27;&gt;(&#x27;1&#x27;, &#x27;a&#x27;, &#x27;A&#x27;)(&#x27;2&#x27;, &#x27;b&#x27;, &#x27;B&#x27;)(&#x27;3&#x27;, &#x27;c&#x27;, &#x27;C&#x27;)[(1, 4), (2, 5), (3, 6)]&lt;zip object at 0x10ec7c480&gt;(1, 4) (2, 5) (3, 6)True 其它内置函数数据类型转换相关内置函数 int() 将其它类型数据转为整型 float() 转为浮点类型 bool() 转为布尔类型 complex() 转为复数 str() 转为字符串类型 list 转为列表类型 tuple 转为元组类型 dict 转为字典类型 set 转为集合类型 变量相关函数 id() 获取当前数据的ID标识 type() 获取当前数据的类型字符串 print() 数据的打印 input() 获取输入的数据 isinstance() 检测是否为指定的数据类型 数学相关函数实例 1234567891011121314151617181920212223242526# 数学相关函数# 获取一个数的绝对值print(abs(-99.99))# 求和 从 start 开始自左向右对 iterable 中的项求和并返回总计值print(sum([1,2,3]))from math import fsumprint(fsum([3.14, 1.23, 1.01]))# 获取最大值print(max([1,2,3]))print(max(99,12,35))# 获取最小值print(min([2,1,6,-9]))print(min(6,7,1,0,-2))# 幂运算 返回 x 的 y 次幂print(pow(2,3))# 四舍五入print(round(3.1415926))print(round(3.1415926,2)) # 小数点保留几位print(round(4.5)) # 奇进偶退 1.5 = 2, 2.5 = 2, 3.5 = 4, 4.5 =4 执行结果: 123456789101199.9965.38399-9-2833.144 进制相关函数实例 1234567891011# bin() 将数值类型转为二进制print(bin(123))# int() 将二进制转为整型print(int(0b1111011))# oct() 转为八进制数print(oct(123))# hex() 转为十六进制数print(hex(123)) 执行结果: 12340b11110111230o1730x7b Ascii码及字符集 Ascii 共计 128个字符，更新于 1986年 主要用于显示现代英语和其他西欧语言。 GB2312-80 是 1980 年制定的中国汉字编码国家标准。共收录 7445 个字符，其中汉字 6763 个。 GBK 于1995年制定 收录了 21003 个汉字。GBK向下与 GB 2312 编码兼容， GBK18030 2001年的1月正式强制执行，是我国制订的以汉字为主并包含多种我国少数民族文字（如藏、蒙古、傣、彝、朝鲜、维吾尔文等）的超大型中文编码字符集强制性标准，其中收入汉字70000余 Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。 它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。 UTF-8 以字节为单位对Unicode进行编码。 实例 12345# 将字符转为 asciiprint(ord(&#x27;A&#x27;))# 将ascii转为字符print(chr(65)) 执行结果: 1265A 高阶函数sorted(iterable,[reverse,key])12345678910sorted()运行原理： 把可迭代数据里面的元素，一个一个的取出来，放到key这个函数中进行处理， 并按照函数中return的结果进行排序，返回一个新的列表功能： 排序参数： iterable 可迭代的数据 （容器类型数据，range数据序列，迭代器） reverse 可选，是否反转，默认为False，不反转， True反转 key 可选， 函数，可以是自定义函数，也可以是内置函数返回值： 排序后的结果 实例 12345678910111213141516171819arr = [3,7,1,-9,20,10]# 默认按照从小到大的方式进行排序print(sorted(arr))# 可以按照从大到小的方式进行排序print(sorted(arr, reverse = True))# 使用abs这个函数(求绝对值）作为sorted的key关键字参数使用print(sorted(arr, key = abs))def getMod(num): return num % 7# 在sorted函数中使用自定义函数对数据进行处理print(sorted(arr, key = getMod))# 使用lambda简化print(sorted(arr, key = lambda x : x % 7)) 执行结果: 12345[-9, 1, 3, 7, 10, 20][20, 10, 7, 3, 1, -9][1, 3, 7, -9, 10, 20][7, 1, 3, 10, -9, 20][7, 1, 3, 10, -9, 20] map(func, *iterables) 对传入的可迭代数据中的每个元素进行处理，返回一个新的迭代器 123456map(func, *iterables)功能： 对传入的可迭代数据中的每个元素放入到函数中进行处理，返回一个新的迭代器参数： func 函数 自定义函数|内置函数 iterables：可迭代的数据返回值：迭代器 实例1 123456789101112# 把一个字符串数字的列表转为 整型的数字列表# 普通的处理方法varlist = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]newlist = []for i in varlist: newlist.append(int(i)) print(newlist)# 使用map函数进行处理varlist2 = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]print(list(map(int, varlist2))) 执行结果: 12[1, 2, 3, 4][1, 2, 3, 4] 实例2 12345678910111213141516# [1,2,3,4] ==&gt; [1,4,9,16]# 普通的处理方法varlist = [1, 2, 3, 4]newlist = []for i in varlist: newlist.append(i ** 2)print(newlist)# 使用map函数进行处理varlist2 = [1, 2, 3, 4]def square(x): return x ** 2print(list(map(square, varlist)))print(list(map(lambda x : x ** 2, varlist))) 执行结果: 123[1, 4, 9, 16][1, 4, 9, 16][1, 4, 9, 16] reduce(func, iterable)12345678910reduce(func,iterable)功能： 每一次从 iterable 拿出两个元素，放入到func函数中进行处理，得出一个计算结果， 然后把这个计算结果和iterable中的第三个元素，放入到func函数中继续运算， 得出的结果和之后的第四个元素，加入到func函数中进行处理，以此类推，直到最后的元素都参与了运算参数： func： 内置函数或自定义函数 iterable： 可迭代的数据返回值：最终的运算处理结果注意： 使用 reduce函数时，需要导入 from functools import reduce 实例1 12345678910from functools import reduce# 将列表[1, 2, 3] -&gt; 123def getNum(x, y): return x * 10 + yvarlist = [1, 2, 3]ret = reduce(getNum, varlist)print(ret, type(ret)) 执行结果: 1123 &lt;class &#x27;int&#x27;&gt; 实例2 123456789101112from functools import reduce# 计算1+2+3+...+100=？# 定义两数相加def add(x, y): return x + yprint(reduce(add, range(1, 101)))# 使用 lambda 匿名函数简化print(reduce(lambda x, y : x + y, range(1, 101))) 执行结果 1250505050 filter(func, iterable)1234567filter(func, iterable)功能： 过滤数据，把 iterable 中的每个元素拿到 func 函数中进行处理， 如果函数返回True则保留这个数据，返回False则丢弃这个数据参数： func 自定义函数 itereble： 可迭代的数据返回值：保留下来的数据组成的 迭代器 实例 12345678910111213141516171819# 要求 保留所有的偶数，丢弃所有的奇数varlist = [1,2,3,4,5,6,7,8,9]# 普通方法实现newlist = []for i in varlist: if i % 2 == 0: newlist.append(i)print(newlist)# 使用 filter 进行处理# 定义一个函数，判断当前这个函数是否为偶数，偶数返回True，奇数返回Falsedef isEven(x): return x &amp; 1 == 0 print(list(filter(isEven, varlist)))# 使用 lambda 匿名函数简化print(list(filter(lambda x : x &amp; 1 == 0, varlist))) 执行结果: 123[2, 4, 6, 8][2, 4, 6, 8][2, 4, 6, 8] 数据类型详解-字符串 回顾字符串的定义方式 了解转义字符 字符串相关的操作 字符串格式化的方法 字符串相关函数 字符串的定义方式 单引号定义字符串 ‘ ’ 双引号定义字符串 “ ” 三引号定义字符串 ‘’‘内容’‘’或者 “”“内容”“” 字符串定义时，引号可以互相嵌套 转义字符 一个普通的字符出现在转义符 的后面时，实现了另外一种意义 转义符，续行符。 作为转义符时，在\\后面出现的字符可能会实现另外一种意义。 作为续行符时，在行尾使用了\\后，可以换行继续书写内容 \\n 代表一个换行符 \\r 代表光标位置（从\\r出现的位置开始作为光标的起点） \\t 代表一个水平制表符（table 缩进） \\b 代表一个退格符 \\\\ 反转义\\，输出了\\，取消\\的转义效果 把转义字符作为普通字符输出,在字符串的前面加 r’ ‘ 实例 123456789101112131415161718192021222324# \\ 续行符vars = &#x27;abc&#x27;\\ &#x27;def&#x27;print(vars)# \\ 转义符，在字符出现的特定字符有着特定的意义# \\n 代表一个换行符print(&#x27;hello\\nworld&#x27;)# \\r 代表光标的位置（从\\r出现的位置开始作为光标的起点）print(&#x27;123\\r456&#x27;)# \\t 水平制表符（table 缩进）print(&#x27;ABC\\tDEF&#x27;)# \\b 退格符print(&#x27;hello\\bworld&#x27;)# \\\\ 一个\\是转义符，在这个符号前在定义一个\\ 就会取消转义。变成一个普通的\\输出print(&#x27;\\\\n是换行符&#x27;)# 把转义字符作为普通字符输出,在字符串的前面加 r&#x27;&#x27;print(r&#x27;AB\\bC&#x27;) 执行结果: 12345678abcdefhelloworld456ABC DEFhellworld\\n是换行符AB\\bC 字符串相关的操作 字符串 + 操作 字符串 * 操作 字符串 [] 切片操作 字符串[开始值：结束值：步进值]开始值：默认为0，结束值默认是最后一个下标，步进值默认为1 实例 1234567891011121314151617181920212223242526272829303132# 字符串 + 操作vara = &#x27;hello&#x27;varb = &#x27;world&#x27;print(vara + &#x27; &#x27; + varb)# 字符串 * 操作print((vara + &#x27; &#x27;) * 2)# 字符串 [] 切片操作 ,左闭右开# 字符串的索引操作，字符串中只能使用[]下标 访问，不能修改&#x27;&#x27;&#x27;0 1 2 3 4 5 6 7 8 9 10 ....h e l l o w o r l d a b c d -4 -3 -2 -1&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;字符串的切片操作str[开始值：结束值：步进值]开始值：默认为0，结束值默认是最后一个下标，步进值默认为1&#x27;&#x27;&#x27;vars = &#x27;AaBbCcDdEeFfGg&#x27;print(vars)print(vars[5]) # 写一个值就是获取指定下标的元素print(vars[2:5]) # 从2下标开始取值，一直到下标5之前，能取到2，取不到5print(vars[3:9:2]) #从3下标开始取值，一直到下标9之前, 每隔一个取一个print(vars[::]) # 从头取到尾print(vars[::2]) # 从头取到尾，每隔一个取一个print(vars[::-1]) # 字符串倒转过来print(vars[::-2]) # 字符串倒转过来，每隔一个取一个print(vars[1::]) # 从1下标开始取到最后一个print(vars[1::2]) # 从1下标开始取到最后一个,每隔一个取一个 执行结果: 123456789101112hello worldhello hello AaBbCcDdEeFfGgcBbCbcdAaBbCcDdEeFfGgABCDEFGgGfFeEdDcCbBaAgfedcbaaBbCcDdEeFfGgabcdefg 字符串格式化的方法 format f 实例 123456789101112131415161718192021222324252627282930313233# 1. 根据索引进行格式化字符print(&#x27;&#123;0&#125;_address: &quot;&#123;1&#125;&quot;&#x27;.format(&#x27;baidu&#x27;, &#x27;www.baidu.com&#x27;))print(&#x27;&#123;1&#125;_address: &quot;&#123;0&#125;&quot;&#x27;.format(&#x27;baidu&#x27;, &#x27;www.baidu.com&#x27;))# 2. 根据关键字进行格式化字符print(&#x27;&#123;name&#125;_address: &quot;&#123;site&#125;&quot;&#x27;.format(name = &#x27;baidu&#x27;, site = &#x27;www.baidu.com&#x27;))# 3. 根据索引和关键字结合进行格式化字符print(&#x27;a1: &#123;0&#125;, a2: &#123;other&#125;, a3: &#123;1&#125;&#x27;.format( &#x27;dog&#x27;, &#x27;cat&#x27;, other = &#x27;tiger&#x27;)) # 4. 容器类型数据传参table = &#123;&#x27;Google&#x27;: 1, &#x27;Baidu&#x27;: 2, &#x27;Bing&#x27;: 3&#125;for name, number in table.items(): print(&#x27;&#123;0:10&#125; ==&gt; &#123;1:10d&#125;&#x27;.format(name, number))# 访问字典print(&#x27;table[Bing] = &#x27;, table[&#x27;Bing&#x27;])print(&#x27;Baidu: &#123;0[Baidu]: d&#125;, Google: &#123;0[Google]: d&#125;, Bing: &#123;0[Bing]: d&#125;&#x27;.format(table))# 限定小数的位数from math import piprint(&quot;PI approximately equal to &#123;0:.3f&#125;&quot;.format(pi))# 古老的语法, 不推荐print(&quot;%d-%d&quot; % (1, 2))# 3.7中新增的 格式化方法 f方法print(f&#x27;&#123;table[&quot;Baidu&quot;]&#125;&#x27;)s1 = &#x27;hello&#x27;s2 = &#x27;world&#x27;print(f&#x27;&#123;s1&#125; ~ &#123;s2&#125;&#x27;) 执行结果: 12345678910111213baidu_address: &quot;www.baidu.com&quot;www.baidu.com_address: &quot;baidu&quot;baidu_address: &quot;www.baidu.com&quot;a1: dog, a2: tiger, a3: catGoogle ==&gt; 1Baidu ==&gt; 2Bing ==&gt; 3table[Bing] = 3Baidu: 2, Google: 1, Bing: 3PI approximately equal to 3.1421-22hello ~ world 字符串相关函数 官方文档：内置类型：字符串 https://docs.python.org/3.7/library/stdtypes.html#text-sequence-type-str (一) 英文字符与字符检测相关函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061vars = &#x27;hello world&#x27;# str.capitalize()# 返回字符串的副本，该字符串的首个字符大写，其余小写。print(&#x27;vars.capitalize():&#x27;, vars.capitalize())# str.title()# 把字符串中的一个单词的首字母大写print(&#x27;vars.title():&#x27;, vars.title())# str.upper()# 把字符串全部改为大写print(&#x27;vars.upper():&#x27;, vars.upper())# str.lower()# 把字符串全部改为小写print(&#x27;vars.lower():&#x27;, vars.lower())# str.swapcase()# 字符串中的大小写字符转换，大写转小写，小写转大写print(&#x27;vars.swapcase():&#x27;, vars.swapcase())# str.isupper()# 检测字符串是否为全部大写字母组成print(&#x27;vars.isupper():&#x27;, vars.isupper())# str.islower()# 检测字符串是否为全部小写字母组成print(&#x27;vars.islower():&#x27;, vars.islower())# str.istitle()# 检测字符串是否符合标题title的要求print(&#x27;vars.istitle():&#x27;, vars.istitle())# str.isalnum()# 检测字符串是否由数字和字母组成，如果字符串中包含来非数字字母的其它字符，则返回Falseprint(&#x27;vars.isalnum():&#x27;, vars.isalnum())# str.isalpha()# 检测字符串是否全部由字符(包含英文字符和中文)组成print(&#x27;vars.isalpha():&#x27;, vars.isalpha())# str.isdigit()# 检测字符串是否由纯数字字符组成print(&#x27;vars.isdigit():&#x27;, vars.isdigit())# str.isspace()# 检测当前字符串是否为 空格 字符组成 &#x27; &#x27;print(&#x27;vars.isspace():&#x27;, vars.isspace())# str.startswith(prefix[, start[, end]]) -&gt; bool# 检测字符串是否以指定的字符开始的，也可以指定开始和结束的位置print(&#x27;vars.startswith(\\&#x27;h\\&#x27;):&#x27;, vars.startswith(&#x27;h&#x27;))print(&#x27;vars.startswith(\\&#x27;w\\&#x27;, 6):&#x27;, vars.startswith(&#x27;w&#x27;, 6))print(&#x27;vars.startswith(\\&#x27;llo\\&#x27;, 2, 6):&#x27;, vars.startswith(&#x27;llo&#x27;, 2, 6))# S.endswith(suffix[, start[, end]]) -&gt; bool# 检测字符串是否以 指定的字符 结束的，也可以指定开始和结束的位置print(&#x27;vars.endswith(\\&#x27;d\\&#x27;):&#x27;, vars.endswith(&#x27;d&#x27;))print(&#x27;vars.endswith(\\&#x27;o\\&#x27;, 0, 5):&#x27;, vars.endswith(&#x27;o&#x27;, 0, 5))print(&#x27;vars.endswith(\\&#x27;rld\\&#x27;, 2, 11):&#x27;, vars.endswith(&#x27;rld&#x27;, 2, 11)) 执行结果: 123456789101112131415161718vars.capitalize(): Hello worldvars.title(): Hello Worldvars.upper(): HELLO WORLDvars.lower(): hello worldvars.swapcase(): HELLO WORLDvars.isupper(): Falsevars.islower(): Truevars.istitle(): Falsevars.isalnum(): Falsevars.isalpha(): Falsevars.isdigit(): Falsevars.isspace(): Falsevars.startswith(&#x27;h&#x27;): Truevars.startswith(&#x27;w&#x27;, 6): Truevars.startswith(&#x27;llo&#x27;, 2, 6): Truevars.endswith(&#x27;d&#x27;): Truevars.endswith(&#x27;o&#x27;, 0, 5): Truevars.endswith(&#x27;rld&#x27;, 2, 11): True （二）字符串 查找与操作相关函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374str1 = &quot;this is string example....wow!!!&quot;str2 = &quot;exam&quot;# 检测一个字符串是否在另一个字符串中print(&#x27;str2 in str1:&#x27;, str2 in str1)# len() 函数可以获取当前字符串的长度print(&#x27;len(str1) =&#x27;, len(str1))# find() 方法 ，从左到右找到则返回字符中符合条件的第一个字符出现的索引位置。未找到返回 -1print(&#x27;str1.find(str2):&#x27;, str1.find(str2))print(&#x27;str1.find(str2, 3, 15):&#x27;, str1.find(&#x27;ing&#x27;, 3, 15))# find() 方法 ，从右向左找到则返回字符中符合条件的第一个字符出现的索引位置。未找到返回 -1print(&#x27;str1.rfind(str2):&#x27;, str1.rfind(str2))print(&#x27;str1.rfind(str2, 3, 15):&#x27;, str1.rfind(&#x27;ing&#x27;, 3, 15))# index() 方法# 找到则返回索引位置，未找到则报错 ValueErrorprint(&#x27;str1.index(str2):&#x27;, str1.index(str2))print(&#x27;str1.index(str2, 3, 15):&#x27;, str1.index(&#x27;ing&#x27;, 3, 15))print(&#x27;str1.rindex(str2):&#x27;, str1.rindex(str2))print(&#x27;str1.rindex(str2, 3, 15):&#x27;, str1.rindex(&#x27;ing&#x27;, 3, 15))# str.count(sub[, start[, end]]) -&gt; int# 统计一个字符串在另一个字符串出现的次数print(&#x27;str1.count(\\&#x27;is\\&#x27;):&#x27;, str1.count(&#x27;is&#x27;))vars = &#x27;user_admin_id_123&#x27;# split(str, num) 方法 可以按照指定的分隔符，把字符串分隔成列表# str: 分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等# num: 分割次数。默认为 -1, 即分隔所有print(&#x27;vars.split(\\&#x27;_\\&#x27;):&#x27;, vars.split(&#x27;_&#x27;))print(&#x27;vars.split(\\&#x27;_\\&#x27;, 2):&#x27;, vars.split(&#x27;_&#x27;, 2))vars1 = &#x27;uid=123&amp;type=ab&amp;kw=hh&#x27;res = vars1.split(&#x27;&amp;&#x27;)for i in res: r = i.split(&#x27;=&#x27;) print(r.pop())# rsplit() 方法是从右向左进行print(&#x27;vars.rsplit(\\&#x27;_\\&#x27;):&#x27;, vars.rsplit(&#x27;_&#x27;)) # [&#x27;user&#x27;, &#x27;admin&#x27;, &#x27;id&#x27;, &#x27;123&#x27;]print(&#x27;vars.rsplit(\\&#x27;_\\&#x27;, 2):&#x27;, vars.rsplit(&#x27;_&#x27;,2)) # [&#x27;user_admin&#x27;, &#x27;id&#x27;, &#x27;123&#x27;]# ** join() 方法 ，使用指定的字符串，把一个容器中的元素链接成一个字符串varlist = [&#x27;user&#x27;, &#x27;admin&#x27;, &#x27;id&#x27;, &#x27;123&#x27;]print(&#x27;\\&#x27;_\\&#x27;.join(varlist):&#x27;, &#x27;_&#x27;.join(varlist))# strip() 去除字符串左右两侧的指定字符# rstrip() 去除字符串右侧的指定字符， lstrip() 去除字符串左侧的指定字符vars = &#x27;##hello###&#x27;print(&#x27;vars.strip(\\&#x27;#\\&#x27;):&#x27;, vars.strip(&#x27;#&#x27;))vars = &#x27;@admin&#x27;print(&#x27;vars.strip(\\&#x27;@\\&#x27;):&#x27;, vars.strip(&#x27;@&#x27;))# replace() 替换函数vars = &#x27;I like you&#x27;# 找到 like 替换为 loveprint(&#x27;vars.replace(\\&#x27;like\\&#x27;, \\&#x27;love\\&#x27;):&#x27;, vars.replace(&#x27;like&#x27;, &#x27;love&#x27;))vars = &#x27;aabbccddeeabcdef&#x27;# 可以限制替换的次数print(&#x27;vars.replace(\\&#x27;a\\&#x27;, \\&#x27;A\\&#x27;, 2):&#x27;, vars.replace(&#x27;a&#x27;,&#x27;A&#x27;,2))# center() 方法将使用指定的字符（默认为空格）作为填充字符使字符串居中对齐。# ljust() 方法返回一个原字符串左对齐,并使用指定的字符（默认为空格）填充至指定长度的新字符串。# 如果指定的长度小于原字符串的长度则返回原字符串。# rjust() 同理vars = &#x27;cube&#x27;print(&#x27;vars.center(10, \\&#x27;*\\&#x27;):&#x27;, vars.center(10, &#x27;*&#x27;))print(&#x27;vars.ljust(10, \\&#x27;*\\&#x27;):&#x27;, vars.ljust(10, &#x27;*&#x27;))print(&#x27;vars.rjust(10, \\&#x27;*\\&#x27;):&#x27;, vars.rjust(10, &#x27;*&#x27;)) 执行结果: 1234567891011121314151617181920212223242526str2 in str1: Truelen(str1) = 32str1.find(str2): 15str1.find(str2, 3, 15): 11str1.rfind(str2): 15str1.rfind(str2, 3, 15): 11str1.index(str2): 15str1.index(str2, 3, 15): 11str1.rindex(str2): 15str1.rindex(str2, 3, 15): 11str1.count(&#x27;is&#x27;): 2vars.split(&#x27;_&#x27;): [&#x27;user&#x27;, &#x27;admin&#x27;, &#x27;id&#x27;, &#x27;123&#x27;]vars.split(&#x27;_&#x27;, 2): [&#x27;user&#x27;, &#x27;admin&#x27;, &#x27;id_123&#x27;]123abhhvars.rsplit(&#x27;_&#x27;): [&#x27;user&#x27;, &#x27;admin&#x27;, &#x27;id&#x27;, &#x27;123&#x27;]vars.rsplit(&#x27;_&#x27;, 2): [&#x27;user_admin&#x27;, &#x27;id&#x27;, &#x27;123&#x27;]&#x27;_&#x27;.join(varlist): user_admin_id_123vars.strip(&#x27;#&#x27;): hellovars.strip(&#x27;@&#x27;): adminvars.replace(&#x27;like&#x27;, &#x27;love&#x27;): I love youvars.replace(&#x27;a&#x27;, &#x27;A&#x27;, 2): AAbbccddeeabcdefvars.center(10, &#x27;*&#x27;): ***cube***vars.ljust(10, &#x27;*&#x27;): cube******vars.rjust(10, &#x27;*&#x27;): ******cube 数据类型详解-列表 列表就是一组有序的数据组合，列表中的数据可以被修改 列表的定义 可以使用 中括号进行定义 [] 也可以使用 list函数 定义 在定义列表中的元素时，需要在每个元素之间使用逗号，进行分隔。[1,2,3,4] 列表中的元素可以是任意类型的，通常用于存放同类项目的集合 列表的基本操作 列表定义-[],list() 列表相加-拼接 列表相乘-重复 列表的下标- 获取,更新 列表元素的添加-append() 列表元素的删除 del 列表[下标] pop()函数 删除元素 列表中切片 语法==&gt; 列表[开始索引:结束索引:步进值] 1。 列表[开始索引:] ==&gt; 从开始索引到列表的最后2。 列表[:结束值] ==&gt; 从开始到指定的结束索引之前3。 列表[开始索引:结束索引] ==&gt; 从开始索引到指定结束索引之前4。 列表[开始索引:结束索引:步进值] ==&gt; 从指定索引开始到指定索引前结束，按照指定步进进行取值切片5。 列表[:] 或 列表[::] ==&gt; 所有列表元素的切片6。 列表[::-1] ==&gt; 倒着获取列表的元素 123456789101112131415161718192021222324252627282930313233varlist = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;ycr&#x27;, &#x27;feliks&#x27;, &#x27;rs&#x27;, &#x27;max&#x27;, &#x27;park&#x27;]# 从开始索引到列表的最后print(&#x27;varlist[2:] =&#x27;, varlist[2:])# 从开始到指定的结束索引之前print(&#x27;varlisst[:2] =&#x27;, varlist[:2])# 从开始索引到指定结束索引之前print(&#x27;varlist[2:5] =&#x27;, varlist[2:5])# 从指定索引开始到指定索引前结束，按照指定步进值进行切片print(&#x27;varlist[2:5:2] =&#x27;, varlist[2:5:2])# 所有列表元素的切片print(&#x27;varlist[:] =&#x27;, varlist[:])print(&#x27;varlist[::] =&#x27;, varlist[::])# 倒着输出列表的元素print(&#x27;varlist[::-1] =&#x27;, varlist[::-1])# 使用切片方法 对列表数据进行更新和删除print(&#x27;varlist =&#x27;, varlist)# 从指定下标开始，到指定下标前结束，并替换为对应的数据(容器类型数据，会拆分成每个元素进行赋值)varlist[2:6] = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;, &#x27;d&#x27;]print(&#x27;varlist =&#x27;, varlist)varlist[2:6:2] = [&#x27;A&#x27;,&#x27;B&#x27;] # 需要与要更新的元素个数对应print(&#x27;varlist =&#x27;, varlist)# 切片删除del varlist[2:6:2]print(&#x27;varlist =&#x27;, varlist) 执行结果: 1234567891011varlist[2:] = [&#x27;ycr&#x27;, &#x27;feliks&#x27;, &#x27;rs&#x27;, &#x27;max&#x27;, &#x27;park&#x27;]varlisst[:2] = [&#x27;hello&#x27;, &#x27;world&#x27;]varlist[2:5] = [&#x27;ycr&#x27;, &#x27;feliks&#x27;, &#x27;rs&#x27;]varlist[2:5:2] = [&#x27;ycr&#x27;, &#x27;rs&#x27;]varlist[:] = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;ycr&#x27;, &#x27;feliks&#x27;, &#x27;rs&#x27;, &#x27;max&#x27;, &#x27;park&#x27;]varlist[::] = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;ycr&#x27;, &#x27;feliks&#x27;, &#x27;rs&#x27;, &#x27;max&#x27;, &#x27;park&#x27;]varlist[::-1] = [&#x27;park&#x27;, &#x27;max&#x27;, &#x27;rs&#x27;, &#x27;feliks&#x27;, &#x27;ycr&#x27;, &#x27;world&#x27;, &#x27;hello&#x27;]varlist = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;ycr&#x27;, &#x27;feliks&#x27;, &#x27;rs&#x27;, &#x27;max&#x27;, &#x27;park&#x27;]varlist = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;park&#x27;]varlist = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;A&#x27;, &#x27;b&#x27;, &#x27;B&#x27;, &#x27;d&#x27;, &#x27;park&#x27;]varlist = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;park&#x27;] 列表相关函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849varlist = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;ycr&#x27;, &#x27;feliks&#x27;, &#x27;rs&#x27;, &#x27;max&#x27;, &#x27;park&#x27;]# len() 检测当前列表的长度，列表中元素的个数print(&#x27;len(varlist) =&#x27;, len(varlist))# count() 检测当前列表中指定元素出现的次数print(&#x27;varlist.count(\\&#x27;rs\\&#x27;) =&#x27;, varlist.count(&#x27;rs&#x27;)) # append() 向列表的尾部追加新的元素，返回值为 Nonevarlist.append(&#x27;qwer&#x27;)# insert() 可以向列表中指定的索引位置添加新的元素，varlist.insert(2, &#x27;A&#x27;)# pop() 可以对指定索引位置上的元素做 出栈 操作，返回出栈的元素print(&#x27;varlist.pop():&#x27;, varlist.pop()) # 默认会把列表中的最后一个元素 出栈print(&#x27;varlist.pop(2):&#x27;, varlist.pop(2)) # 会在列表中把指定索引的元素进行 出栈varlist = [1,2,3,4,11,22,33,44,1,2,3,4]# remove() 可以指定列表中的元素 进行 删除,只删除第一个。如果没有找到，则报错varlist.remove(1)# index() 可以查找指定元素在列表中第一次出现的索引位置print(&#x27;varlist.index(1) =&#x27;, varlist.index(1))print(&#x27;varlist.index(1, 5, 20) =&#x27;, varlist.index(1,5,10)) # 可以在指定索引范围内查找元素的索引位置# extend() 接收一个容器类型的数据，把容器中的元素追加到原列表中varlist.extend(&#x27;123&#x27;)varlist.extend([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;])print(&#x27;varlist after extend:&#x27;, varlist)# s.clear() # 清空列表内容varlist.clear()print(&#x27;varlist after clear:&#x27;, varlist)varlist = [1, 2, 3]# reverse() 列表翻转varlist.reverse()print(&#x27;varlist after reverse:&#x27;, varlist)varlist = [5, 7, 2, 1, -3, 9, 8]# sort() 对列表进行排序varlist.sort() # 默认对元素进行从小到大的排序print(&#x27;varlist sort:&#x27;, varlist)varlist.sort(reverse=True) # 对元素进行从大到小的排序print(&#x27;varlist sort(reverse=True):&#x27;, varlist)varlist.sort(key=abs) # 可以传递一个函数，按照函数的处理结果进行排序print(&#x27;varlist sort(key=abs):&#x27;,varlist) 执行结果： 123456789101112len(varlist) = 7varlist.count(&#x27;rs&#x27;) = 1varlist.pop(): qwervarlist.pop(2): Avarlist.index(1) = 7varlist.index(1, 5, 20) = 7varlist after extend: [2, 3, 4, 11, 22, 33, 44, 1, 2, 3, 4, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]varlist after clear: []varlist after reverse: [3, 2, 1]varlist sort: [-3, 1, 2, 5, 7, 8, 9]varlist sort(reverse=True): [9, 8, 7, 5, 2, 1, -3]varlist sort(key=abs): [1, 2, -3, 5, 7, 8, 9] 深拷贝与浅拷贝浅拷贝 浅拷贝只能拷贝列表中的一维元素，如果列表中存在二维元素或容器，则引用而不是拷贝 使用cpoy函数或者copy模块中的copy函数拷贝的都是浅拷贝 1234567891011121314151617181920212223242526272829# 浅拷贝 只能拷贝当前列表，不能拷贝列表中的多维列表元素varlist = [1,2,3]# 简单的拷贝 就可以把列表复制一份newlist = varlist.copy()# 对新拷贝的列表进行操作，也是独立的del newlist[1]print(&#x27;varlist: &#123;&#125;, id: &#123;&#125;&#x27;.format(varlist, id(varlist)))print(&#x27;newlist: &#123;&#125;, id: &#123;&#125;&#x27;.format(newlist, id(newlist)))# 多维列表varlist = [1, 2, 3, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]]# 使用copy函数 拷贝一个多维列表newlist = varlist.copy()del newlist[1]print(&#x27;varlist: &#123;&#125;, id: &#123;&#125;&#x27;.format(varlist, id(varlist)))print(&#x27;newlist: &#123;&#125;, id: &#123;&#125;&#x27;.format(newlist, id(newlist)))varlist = [1, 2, 3, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]]newlist = varlist.copy()# 如果是一个被拷贝的列表，对它的多维列表元素进行操作时，会导致原列表中的多维列表也发生了变化del newlist[3][1]print(&#x27;varlist: &#123;&#125;, id: &#123;&#125;&#x27;.format(varlist, id(varlist)))print(&#x27;newlist: &#123;&#125;, id: &#123;&#125;&#x27;.format(newlist, id(newlist)))# 通过id检测，发现列表中的多维列表是同一个元素（对象）print(&#x27;id(newlist[3]):&#x27;, id(newlist[3]))print(&#x27;id(varlist[3]):&#x27;, id(varlist[3])) 执行结果： 12345678varlist: [1, 2, 3], id: 4327857792newlist: [1, 3], id: 4328524800varlist: [1, 2, 3, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]], id: 4326809152newlist: [1, 3, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]], id: 4327857792varlist: [1, 2, 3, [&#x27;a&#x27;, &#x27;c&#x27;]], id: 4328524992newlist: [1, 2, 3, [&#x27;a&#x27;, &#x27;c&#x27;]], id: 4326809152id(newlist[3]): 4328524800id(varlist[3]): 4328524800 深拷贝 深拷贝就是不光拷贝了当前的列表，同时把列表中的多维元素或容器也拷贝了一份，而不是引用 使用copy模块中的 deepcopy 函数可以完成深拷贝 12345678910111213# 深拷贝 就是不光拷贝了当前的列表，同时把列表中的多维元素也拷贝了一份import copyvarlist = [1, 2, 3, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]]# 使用 copy模块中 深拷贝方法 deepcopynewlist = copy.deepcopy(varlist)print(&#x27;varlist[3]: &#123;&#125;, id(varlist[3]): &#123;&#125;&#x27;.format(varlist[3], id(varlist)))print(&#x27;newlist[3]: &#123;&#125;, id(newlist[3]): &#123;&#125;&#x27;.format(newlist[3], id(newlist)))del varlist[3][1]print(&#x27;varlist: &#123;&#125;, id(varlist): &#123;&#125;&#x27;.format(varlist, id(varlist)))print(&#x27;varlist: &#123;&#125;, id(varlist): &#123;&#125;&#x27;.format(varlist, id(varlist))) 执行结果： 1234varlist[3]: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], id(varlist[3]): 4405437632newlist[3]: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], id(newlist[3]): 4405437120varlist: [1, 2, 3, [&#x27;a&#x27;, &#x27;c&#x27;]], id(varlist): 4405437632varlist: [1, 2, 3, [&#x27;a&#x27;, &#x27;c&#x27;]], id(varlist): 4405437632 列表推到式 List-Comprehensions 列表推导式提供了一个更简单的创建列表的方法。 常见的用法是把某种操作应用于序列或可迭代对象的每个元素上，然后使用其结果来创建列表，或者通过满足某些特定条件元素来创建子序列。 采用一种表达式的当时，对数据进行过滤或处理，并且把结果组成一个新的列表 一 基本的列表推到式使用方式 结果变量 = [变量或变量的处理结果 for 变量 in 容器类型数据] 1234567891011121314151617181920212223242526272829303132333435363738# 1 假设我们想创建一个平方列表# 使用普通方法完成varlist = []for i in range(10): varlist.append(i**2)print(varlist) varlist.clear()# 使用 map函数和list完成varlist = list(map(lambda x: x**2, range(10)))print(varlist) varlist.clear()# 使用列表推导式完成 下面这个列表推导式和第一种方式是一样的varlist = [i**2 for i in range(10)]print(varlist) varlist.clear()# 2。 &#x27;1234&#x27; ==&gt; [2,4,6,8]# 常规方法完成需求varstr = &#x27;1234&#x27;newlist = []for i in varstr: newlist.append(int(i)*2)print(newlist) newlist.clear()# 使用列表推到式完成上面的需求newlist = [int(i)*2 for i in varstr]print(newlist) newlist.clear()# 使用列表推到式+位运算完成newlist = [int(i) &lt;&lt; 1 for i in varstr]print(newlist) newlist.clear() 执行结果： 123456[0, 1, 4, 9, 16, 25, 36, 49, 64, 81][0, 1, 4, 9, 16, 25, 36, 49, 64, 81][0, 1, 4, 9, 16, 25, 36, 49, 64, 81][2, 4, 6, 8][2, 4, 6, 8][2, 4, 6, 8] 二 带有判断条件的列表推到式 结果变量 = [变量或变量的处理结果 for i in 容器类型数据 条件表达式] 示例： 123456789101112# 1-9 求所有的偶数，==&gt; [2, 4, 6, 8]# 常规方法完成newlist = []for i in range(1, 10): if i % 2 == 0: newlist.append(i)print(newlist) # 列表推到式完成newlist = [i for i in range(1, 10) if i % 2 == 0]print(newlist) 执行结果： 12[2, 4, 6, 8][2, 4, 6, 8] 三 对于嵌套循环的列表推到式12345678910111213141516171819202122232425262728293031323334&#x27;&#x27;&#x27;# 下面这个 3x4的矩阵，它由3个长度为4的列表组成，交换其行和列[ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],]==&gt;[ [1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]&#x27;&#x27;&#x27;arr = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],]# 常规方法完成newlist = []for i in range(4): res = [] for row in arr: res.append(row[i]) newlist.append(res)print(newlist)# 使用列表推到式完成newlist = [[row[i] for row in arr] for i in range(4)]print(newlist) 执行结果： 12[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]][[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] 数据类型详解-元组 元组和列表一样都是一组有序的数据的组合。 元组中的元素一但定义不可以修改，因此元组称为 不可变数据类型 元组定义 定义空元组 变量 = (),或者 变量=tuple() 还可以使用 变量 = (1,2,3) 定义含有数据的元组 注意：如果元组中只有一个元素时，必须加逗号 变量=(1,) 特例：变量=1,2,3 这种方式也可以定义为一个元组 元组的相关操作 由于元组是不可变的数据类型，因次只能使用索引进行访问，不能进行其它操作 元组可以和列表一样使用切片方式获取元素 元组的切片操作 元组的切片操作 和列表是一样的 123456789vart = (1,2,3,4,5,5,4,3,2,1)res = vart[:] # 获取全部res = vart[::] # 获取全部res = vart[1:] # 从索引1开始获取到最后res = vart[1:3] # 从索引1开始到索引3之前res = vart[:3] # 从索引 0 开始 到 索引 3之前res = vart[1:5:2] # 从索引1开始到索引5之前，步进值为2res = vart[::2] # 从索引 0 开始 到 最后 ，步进值为2res = vart[5:1:-1] # 从索引5开始 到索引 1，步进值为-1 倒着输出 元组推导式 生成器 列表推导式结果返回了一个列表，元组推导式返回的是生成器 语法： 列表推导式 ==&gt; [变量运算 for i in 容器] ==&gt; 结果 是一个 列表 元组推导式 ==&gt; (变量运算 for i in 容器) ==&gt; 结果 是一个 生成器 生成器是什么？ 生成器是一个特殊的迭代器，生成器可以自定义，也可以使用元组推导式去定义 生成器是按照某种算法去推算下一个数据或结果，只需要往内存中存储一个生成器，节约内存消耗，提升性能 语法： 里面是推导式，外面是一个() 的结果就是一个生成器 自定义生成器，含有yield关键字的函数就是生成器 含有yield关键字的函数，返回的结果是一个迭代器，换句话说，生成器函数就是一个返回迭代器的函数 如何使用操作生成器？​ 生成器是迭代器的一种，因此可以使用迭代器的操作方法来操作生成器 示例代码: 1234567891011121314151617181920# 列表推导式varlist = [1,2,3,4,5,6,7,8,9]# newlist = [i**2 for i in varlist]# print(newlist) # [1, 4, 9, 16, 25, 36, 49, 64, 81]# 元组推导式 生成器 generatornewt = (i**2 for i in varlist)print(newt) # &lt;generator object &lt;genexpr&gt; at 0x1104cd4d0&gt;# 使用next函数去调用# print(next(newt))# print(next(newt))# 使用list或tuple函数进行操作# print(list(newt))# print(tuple(newt))# 使用 for 进行遍历# for i in newt:# print(i) 数据类型详解-字典 字典也是一种数据的集合，由键值对组成的数据集合，字典中的键不能重复 字典中的键必须是不可变的数据类型，常用的键主要是：字符串，整型。。。 字典的定义 字典可以通过将以逗号分隔的 键: 值 对列表包含于花括号之内来创建字典 也可以通过 dict 构造器来创建 &#123;&#39;jack&#39;: 4098, &#39;sjoerd&#39;: 4127&#125; 或 &#123;4098: &#39;jack&#39;, 4127: &#39;sjoerd&#39;&#125; 12345678910111213141516# 1。 使用&#123;&#125;定义vardict = &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2,&#x27;c&#x27;:2&#125;# 2。 使用 dict(key=value,key=value) 函数进行定义vardict = dict(name=&#x27;zhangsan&#x27;,sex=&#x27;男&#x27;,age=22)# 3。 数据类型的转换 dict(二级容器类型) 列表或元组，并且是二级容易才可以转换vardict = dict([[&#x27;a&#x27;,1],[&#x27;b&#x27;,2],[&#x27;c&#x27;,3]]) # &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;# 4。zip压缩函数，dict转类型var1 = [1,2,3,4]var2 = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]# 转换的原理和上面的第三种 是一个原理vardict = dict(zip(var1,var2)) # &#123;1: &#x27;a&#x27;, 2: &#x27;b&#x27;, 3: &#x27;c&#x27;, 4: &#x27;d&#x27;&#125;print(vardict) 字典的操作1234567891011121314151617181920var1 = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;var2 = &#123;1: &#x27;a&#x27;, 2: &#x27;b&#x27;, 3: &#x27;c&#x27;, 4: &#x27;d&#x27;&#125;# res = var1 + var2 # XXXX TypeError# res = var1 * 3 # xxxx TypeError# 获取元素res = var1[&#x27;a&#x27;]# 修改元素res = var1[&#x27;a&#x27;] = 111# 删除元素del var1[&#x27;a&#x27;]# 添加元素var1[&#x27;aa&#x27;] = &#x27;AA&#x27;# 如果字典中的key重复了，会被覆盖# var1[&#x27;aa&#x27;] = &#x27;aa&#x27; 成员检测和获取12345678910111213# 三 成员检测和获取 ,只能检测key，不能检测valueres = &#x27;AA&#x27; in var1res = &#x27;AA&#x27; not in var1# 获取当前字典的长度 只能检测当前又多少个键值对res = len(var1)# 获取当前字典中的所有 key 键res = var1.keys()# 获取字典中所有的 value 值res = var1.values()# 获取当前字典中所有 键值对res = var1.items() 字典的遍历1234567891011121314151617181920# 四， 对字典进行遍历# （1）在遍历当前的字典时，只能获取当前的keyfor i in var1: print(i) # 只能获取 key print(var1[i]) # 通过字典的key获取对应value#（2）遍历字典时，使用 items() 函数，可以在遍历中获取key和valuefor k,v in var1.items(): print(k) # 遍历时的 key print(v) # 遍历时的 valueprint(&#x27;====&#x27;*20)# (3) 遍历字典的所有keyfor k in var1.keys(): print(k)print(&#x27;====&#x27;*20)# (4) 遍历字典的所有 valuefor v in var1.values(): print(v) 字典的相关函数123456789101112131415161718192021222324252627282930313233# 字典相关函数# len(字典) #获取字典的键值对个数# dict.keys() # 获取当前字典的所有key 键，组成的列表# dict.values() # 获取当前字典的所有 value 值，组成的列表# dict.items() # 返回由字典项 ((键, 值) 对) 组成的一个新视图# iter(d) 返回以字典的键为元素的迭代器。vardict = &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2,&#x27;c&#x27;:3&#125;# dict.pop(key) # 通过 key 从当前字典中弹出键值对 删除# res = vardict.pop(&#x27;a&#x27;)# dict.popitem() LIFO: Last in, First out.后进先出# res = vardict.popitem() # 把最后加入到字典中的键值对删除并返回一个元组# 使用key获取字典中不存在元素，会报错# print(vardict[&#x27;aa&#x27;])# 可以使用get获取一个元素，存在则返回，不存在默认返回None# res = vardict.get(&#x27;aa&#x27;)# res = vardict.get(&#x27;aa&#x27;,&#x27;abc&#x27;)# dict.update(),更新字典,如果key存在，则更新，对应的key不存在则添加# vardict.update(a=11,b=22)# vardict.update(&#123;&#x27;c&#x27;:33,&#x27;d&#x27;:44&#125;)# dict.setdefault(key[,default])# 如果字典存在键 key ，返回它的值。# 如果不存在，插入值为 default 的键 key ，并返回 default 。# default 默认为 None。res = vardict.setdefault(&#x27;aa&#x27;,&#x27;123&#x27;)print(res)print(vardict) 字典推导式12345678910111213141516171819202122232425262728293031# 把字典中的键值对位置进行交换 &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2,&#x27;c&#x27;:3&#125;vardict = &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2,&#x27;c&#x27;:3&#125;# 普通方法实现 字典中的键值交换 &#123;1: &#x27;a&#x27;, 2: &#x27;b&#x27;, 3: &#x27;c&#x27;&#125;newdict = &#123;&#125;for k,v in vardict.items(): newdict[v] = k# print(newdict)# 使用字典推导式完成 &#123;1: &#x27;a&#x27;, 2: &#x27;b&#x27;, 3: &#x27;c&#x27;&#125;newdict = &#123;v:k for k,v in vardict.items()&#125;# print(newdict)# 注意：以下推导式，返回的结果是一个集合，集合推导式# newdict = &#123;v for k,v in vardict.items()&#125;# print(newdict,type(newdict))# 把以下字典中的是偶数的值，保留下来，并且交换键值对的位置vardict = &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2,&#x27;c&#x27;:3,&#x27;d&#x27;:4&#125;# 普通方式完成 &#123;2: &#x27;b&#x27;, 4: &#x27;d&#x27;&#125;# newdict = &#123;&#125;# for k,v in vardict.items():# if v % 2 == 0:# newdict[v] = k# print(newdict)# 字典推导式完成 &#123;2: &#x27;b&#x27;, 4: &#x27;d&#x27;&#125;newdict = &#123;v:k for k,v in vardict.items() if v % 2 == 0&#125;# print(newdict) 数据类型详解-集合 确定的一组无序的数据的组合 确定的？ 当前集合中元素的值不能重复 由多个数据组合的复合型数据（容器类型数据） 集合中的数据没有顺序 功能：成员检测、从序列中去除重复项以及数学中的集合类计算，例如交集、并集、差集与对称差集等等。 集合的定义 可以直接使用 {} 来定义集合 可以使用set()进行集合的定义和转换 使用集合推导式完成集合的定义 注意：集合中的元素不能重复，集合中存放的数据：Number,Strings,Tuple,冰冻集合 集合的基本操作和常规函数1234567891011121314151617181920212223242526272829303132333435363738394041424344# 定义集合vars = &#123;123,&#x27;abc&#x27;,False,&#x27;hello&#x27;,True,(1,2,3),0,3.1415,&#x27;123&#x27;&#125;# 1。无序。# 2。布尔类型 True 表示为 1，False 表示为 0，布尔和数字只存在一个# 3。元素的值不能重复# &#123;0, &#x27;abc&#x27;, &#x27;love&#x27;, True, 3.1415, (1, 2, 3), 123&#125;# 检测集合中的值res = &#x27;123&#x27; in varsres = &#x27;123&#x27; not in vars# 获取集合中元素的个数 len()# res = len(vars)# 集合的遍历# for i in vars:# print(i,type(i))# 向集合中追加元素 add()res = vars.add(&#x27;def&#x27;)# 删除集合中的元素 随机删除一个元素并返回 abc False True 3.1415# r1 = vars.pop()# 指定删除集合中的元素 remove() 返回None，不存在则报错# res = vars.remove(&#x27;aaa&#x27;)# discard 指定删除集合中的元素，不存在也不会报错# res = vars.discard(&#x27;aaa&#x27;)# clear() 清空集合# res = vars.clear()# update(others) 更新集合，添加来自 others 中的所有元素。res = vars.update(&#123;1,2,3,4,5&#125;)# 当前集合中的浅拷贝并不存在 深拷贝的问题res = vars.copy()&#x27;&#x27;&#x27;当前集合中的浅拷贝并不存在 深拷贝的问题 因为集合中的元素都是不可变，包括元组和冰冻集合 不存在拷贝后，对集合中不可变的二级容器进行操作的问题&#x27;&#x27;&#x27; 冰冻集合（了解） 定义冰冻集合，只能使用 frozenset() 函数进行冰冻集合的定义 冰冻集合一旦定义不能修改 冰冻集合只能做集合相关的运算：求交集，差集，。。。 frozenset() 本身就是一个强制转换类的函数，可以把其它任何容器类型的数据转为冰冻集合 12345678910111213141516# 定义vars = frozenset(&#123;&#x27;hello&#x27;,666,&#x27;a&#x27;,1,&#x27;b&#x27;,2,&#x27;123&#x27;&#125;)# vars = frozenset([1,2,3])# 遍历# for i in vars:# print(i)# 冰冻集合的推导式res = frozenset(&#123;i&lt;&lt;1 for i in range(6)&#125;)# 冰冻集合可以和普通集合一样，进行集合的运算 交集。。。# copy()res = res.copy()# print(res) 集合的推导式123456789101112131415161718192021222324# 集合推导式varset = &#123;1,2,3,4&#125;# (1) 普通推导式newset = &#123;i&lt;&lt;1 for i in varset &#125;# (2) 带有条件表达式的推导式newset = &#123;i&lt;&lt;1 for i in varset if i%2==0&#125;# (3) 多循环的集合推导式vars1 = &#123;1,2,3&#125;vars2 = &#123;4,5,6&#125;# newset = set()# for i in vars1:# for j in vars2:# print(i,j)# newset.add(i+j)# print(newset)newset = &#123;i+j for i in vars1 for j in vars2&#125;# print(newset)# (4) 带条件表达式的多循环的集合推导式newset = &#123;i+j for i in vars1 for j in vars2 if i%2==0 and j%2==0&#125;print(newset) 集合的运算集合的主要运算 交集 &amp; set.intersection() set.intersection_update() 并集 | union() update() 差集 - difference(),difference_update() 对称差集 ^ symmetric_difference() symmetric_difference_update() 123456789101112131415161718192021222324252627282930313233343536373839404142vars1 = &#123;&#x27;feliks&#x27;, &#x27;lucas&#x27;, &#x27;hello&#x27;,1&#125;vars2 = &#123;&#x27;ycr&#x27;, &#x27;rs&#x27;, &#x27;cuber&#x27;,1&#125;# &amp; 求两个集合相交的部分res = vars1 &amp; vars2# | 求两个集合的并集，就是把集合中所有元素全部集中起来，（去除重复）res = vars1 | vars2# - 差集运算res = vars1 - vars2 # vars1有，而，vars2 没有的res = vars2 - vars1 # vars2有，而，vars1 没有的# ^ 对称差集res = vars1 ^ vars2# 交集运算函数 intersection intersection_update# set.intersection() # 返回交集的结果 新的集合# res = vars1.intersection(vars2)# set.intersection_update() # 没有返回值# 计算两个集合的相交部分，把计算结果重新赋值给第一个集合# res = vars1.intersection_update(vars2)# 并集运算函数 | union() update()# res = vars1.union(vars2) # 返回并集结果，新的集合# 求并集运算，并且把结果赋值给第一个集合# res = vars1.update(vars2) # 没有返回值# print(vars1)# 差集运算 函数 difference(),difference_update()# res = vars1.difference(vars2) # 返回差集结果 新的集合# 把差集的结果，重新赋值给第一个集合# res = vars1.difference_update(vars2) # 没有返回值# 求对称差集# res = vars1.symmetric_difference(vars2) # 返回对称差集的结果 新的集合# 把对称差集的运算结果，重新赋值给第一个集合res = vars1.symmetric_difference_update(vars2)# 没有返回值 集合检测 issuperset() 检测是否为超集 issubset() 检测是否为子集 isdisjoint() 检测是否不相交 123456789101112131415161718# 检测 超集 子集vars1 = &#123;1,2,3,4,5,6,7,8,9&#125;vars2 = &#123;1,2,3&#125;# issuperset() 检测是否为超集res = vars1.issuperset(vars2) # True vars1是vars2的超集res = vars2.issuperset(vars1) # False# issubset() 检测是否为子集res = vars1.issubset(vars2) # Falseres = vars2.issubset(vars1) # True vars2是vars1的子集# 检测两个集合是否相交vars1 = &#123;1,2,3&#125;vars2 = &#123;5,6,3&#125;# isdisjoint 检测是否不相交， 不相交返回True，相交则返回Falseres = vars1.isdisjoint(vars2)print(res) Python中的File(文件)操作 针对磁盘中的文件的读写。文件I/O I 输入(input) O输出（Output） 文件操作步骤：1.打开文件 2.读写文件 3.关闭文件 写入文件的操作：（把大象装进冰箱） 打开文件 open() ==&gt; 打开冰箱 写入内容 write() ==&gt; 把大象装进冰箱 关闭文件 close() ==&gt; 关闭冰箱门 读取文件的操作：（把大象从冰箱中取出） 打开文件 open() ==&gt; 打开冰箱门 读取内容 read() ==&gt; 把大象拿出来 关闭文件 close() ==&gt; 关闭冰箱门 文件操作相关函数open() 打开文件 格式： open(文件的路径，打开的方式，[字符集]) Seek() 设置文件指针的位置 123fp.seek(0) # 把文件指针设置到文件的开头位置fp.seek(10) # 设置文件指针的位置fp.seek(0,2) # 0,2是把文件指定设置在文件的末尾 write() 写入内容 格式：文件对象.write(字符串) writelines() 写入容器类型数据 格式：文件对象.write(容器类型数据) 注意：容器类型数据中的元素也必须是可写入的字符串类型 read() 读取内容 格式：文件对象.read() 从当前指针位置读取到最后 格式：文件对象.read(读取的字节数) 可以读取指定长度的字符 readline() 读取一行 格式： 文件对象.readline() 一次读取一行 格式： 文件对象.readline(字节数) 一次读取一行中指定长度的字节 readlines() 读取所有行 格式： 文件对象.readlines() 读取所有行，每一行作为一个元素，返回了一个列表 格式：文件对象.readlines(6) 按照行进行读取，可以设置读取的字节数，设置的字节数不足一行按一行算 close() 关闭文件 格式：文件对象.close() 关闭打开的文件 文件操作的高级便捷写法123456789# 文件操作的 高级写法&#x27;&#x27;&#x27;with open(文件路径，打开模式) as 变量： 变量.操作()&#x27;&#x27;&#x27;with open(&#x27;./1.txt&#x27;,&#x27;r+&#x27;,encoding=&#x27;utf-8&#x27;) as fp: res = fp.read() print(res) 文件的路径：12345678910文件路径 路径 url 统一资源定位符#相对路径： 就像给别人指路一样： 在某某大厦的对面。。。 针对文件的相对路径的表示，从当前目录开始计算 1.txt ==&gt; 具体文件前没有任何表示时，默认为当前目录 和 ./1.txt 是一个位置 ./1.txt ==&gt; ./ 代表当前目录中的 1.txt ../1.txt ==&gt; ../ 代表当前目录中的 上一级目录中的1.txt#绝对路径： 就像买东西写收货地址一样： 北京市海淀区中关村大街128号xxx小区，xxx号楼xx单元xx室 windows： c:/users/appdata/1.txt Linux： /user/home/yc/1.txt 打开的模式：1234567891011121314151617181920212223242526272829#一，基础模式: w r x a w w模式 write 写入模式 1。 文件如果不存在，则创建这个文件 2。 文件如果存在，则打开这个文件，并且清空文件内容 3。 文件打开后，文件的指针在文件的最前面 r r模式： read 读取模式 1。 如果文件不存在，则报错 2。 文件如果存在，则打开文件 3。 文件指针在文件的最前面 x x模式： xor 异或模式 1。文件不存在，则创建这个文件 2。文件已存在，则报错（防止覆盖） 3。文件的指针在文件的最前面 a a模式： append 追加模式 1。文件不存在，则创建文件 2。文件如果存在，则打开文件 （和w模式的区别在于。a模式打开文件后不会清空） 3。文件指针在当前文件的最后#二，扩展模式： b b模式 bytes 二进制 + +模式 plus 增强模式（可读可写）#三，文件操作模式的组合： w,r,a,x wb,rb,ab,xb, w+,r+,a+,x+ wb+,rb+,ab+,xb+ 系统内置模块 系统内置模块就是按照python解释器后，系统给提供的模块 在需要时可以导入后使用，例如：json，re，os。。。 序列化模块 序列化是指可以把python中的数据，以文本或二进制的方式进行转换，并且还能反序列化为原来的数据 数据在程序与网络中进行传输和存储时，需要以更加方便的形式进行操作，因此需要对数据进行序列化 对数据进行序列化的主要方法有以下两种 二进制序列化模块 pickle （python专用） 文本序列化模块 json （互联网通用） pickle 序列化 dumps() 序列化，可以把一个python的任意对象序列化成为一个二进制 返回一个序列化后的二进制数据 pickle.dumps(var) loads() 反序列化，可以把一个序列化后的二进制数据反序列化为python的对象 返回一个反序列化后的python对象 pickle.dumps(var) dump() 序列化，把一个数据对象进行序列化并写入到文件中 参数1，需要序列化的数据对象 参数2，写入的文件对象 pickle.dump(var,fp) load() 发序列化，在一个文件中读取序列化的数据，并且完成一个反序列化 参数1，读取的文件对象 pickle.load(fp) json 序列化 JSON (JavaScript Object Notation)JSON 是一个受 JavaScript 的对象字面量语法启发的轻量级数据交换格式。JSON 在js语言中是一个对象的表示方法，和Python中的字典的定义规则和语法都很像JSON 在互联网中又是一种通用的数据交换，数据传输，数据定义的一种数据格式 json.dumps() 完成json格式数据的序列化 json.loads() 完成json格式数据的反序列化 json.dump() 和pickle模块的dump方法一样 json.load() 和pickle模块的load方法一样 扩展了解json json数据格式： 123456789// data.json// 以下三种格式都属于json格式化数据&#123;&#x27;name&#x27;:&#x27;admin&#x27;,&#x27;age&#x27;:20,&#x27;sex&#x27;:&#x27;男&#x27;&#125; # 1[1,2,3] # 2 # 3[ &#123;&#x27;name&#x27;:&#x27;admin&#x27;,&#x27;age&#x27;:20,&#x27;sex&#x27;:&#x27;男&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;aa&#x27;,&#x27;age&#x27;:21,&#x27;sex&#x27;:&#x27;m&#x27;&#125;] js对象定义： 12345// demo.js// javascript 中的对象定义方法var obj = &#123;&#x27;name&#x27;:&#x27;admin&#x27;,&#x27;age&#x27;:20,&#x27;sex&#x27;:&#x27;男&#x27;&#125;// javascript 中的数组定义方法var arr = [1,2,3] 数学与数值相关模块数学模块 Math python中的内置数学模块Math，提供了很多的数学相关运算 文档地址： https://docs.python.org/zh-cn/3.7/library/math.html#module-math 1234567数论与表示函数幂函数与对数函数三角函数角度转换双曲函数特殊函数常量 示例： 12345678910111213141516171819202122232425262728293031323334import math# math的相关函数。一部分# math.ceil() 向上取整,内置函数 round() 四舍五入res = math.ceil(2.55)# math.floor() 向下取整，res = math.floor(2.55)# math.pow() 计算数值的n次方,结果是浮点res = math.pow(2,3)# math.sqrt() 开平方运算，结果是浮点res = math.sqrt(12)# math.fabs() 计算绝对值,结果是浮点res = math.fabs(-3.14)# math.modf() 把一个数值拆分成小数和整数组成的元组res = math.modf(3) #(0.0, 3.0)# math.copysign(x,y) 把第二个参数的正负符合拷贝给第一个参数,结果为浮点数res = math.copysign(-3,99)# math.fsum() 将一个容器类型数据中的元素进行一个求和运算，结果为浮点数# res = math.fsum(&#x27;123&#x27;) # X TypeError: must be real number, not str# res = math.fsum(&#123;1,2,3&#125;) # 注意：容器中的元素必须是可以运算的number类型# math.factorial(x) 以一个整数返回 x 的阶乘res = math.factorial(10) ## 常量# 数学常数 π = 3.141592...，精确到可用精度。res = math.piprint(res) 随机模块 random示例： 12345678910111213141516171819202122232425import random# random.random() 返回 0 - 1 之间的随机小数 (左闭右开)res = random.random()# random.randrange([开始值]，结束值，[步进值]) 随机获取指定范围内的整数res = random.randrange(5) # 一个参数，从0到整数之间的值，左闭右开res = random.randrange(5,10) # 两个参数，从第一个值到第二个值之间的随机数，左闭右开# res = random.randrange(5,10,2) # 三个参数，按照指定步进值从第一个值到第二个值之间的随机数，左闭右开# 随机数的应用场景：数字验证码，高并发下的订单号。。。# random.randint() 随机产生指定范围内的随机整数res = random.randint(5,10)# random.uniform() 获取指定返回内的随机小数res = random.uniform(5,10)# random.choice() 随机获取容器类型中的值res = random.choice(&#x27;123&#x27;)res = random.choice([1,2,3,4])# random.shuffle() 随机打乱当前列表中的值,没有返回值，直接打乱原数据arr = [1,2,3,4,5]res = random.shuffle(arr)# print(res,arr) 系统操作相关模块os 操作系统接口模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import os#1. os.getcwd() 获取当前的工作目录,注意获取的不是当前脚本的目录，res = os.getcwd()# 如果在当前目录执行这个脚本文件，那么getcwd获取的就是当前的文件目录# 如果把执行的目录切换到其它位置，在执行当前脚本，那么获取的就是你执行这个脚本时的目录#2. os.chdir() # 修改当前的工作目录# os.chdir(&#x27;/Users/yc/&#x27;)# 修改工作目录后，再去获取工作目录res = os.getcwd()#3. os.listdir() 获取当前或指定目录中的所有项（文件，文件夹，隐藏文件），组成的列表res = os.listdir() # 不指定目录时，默认为当前的工作目录 == linux 中的 ls -al == windows dirres = os.listdir(path=&#x27;/users/yc/Desktop/code&#x27;) # == linux 中的 ls -al == windows dir#4. os.mkdir(文件夹路径，权限) # 创建文件夹# os.mkdir(&#x27;aa&#x27;,0o777) # 默认在工作目录创建一个人文件夹&#x27;&#x27;&#x27; 关于系统中的文件权限，仅限linux系统 drwxr-xr-x 4 yc staff 128 11 27 11:40 aa dr----x--x 2 yc staff 64 11 27 11:42 abc 第一位 d代表是一个目录，如果是-则表示为一个文件 前三位的rwx 代表文件所有人( u )的权限 中间三位的 r-x 代表文件所属组( g )的权限 最后三位的 r-x 代表其他人( o )的权限 其中 r w x 代表不同的操作权限 777 分别代表 所有人，所属组，和其它 r 表示是否可读， 4 w 表示是否可写 2 x 表示是否可执行 1 注意：无法使用python去创建一个比自己这个进程权限还高的文件&#x27;&#x27;&#x27;# abc/a/b/c 都不存在时，无法使用 mkdir进行递归创建# os.mkdir(&#x27;/users/yc/Desktop/code/abc/a/b/c&#x27;)# 5. os.makedirs() 可以递归创建文件夹# os.makedirs(&#x27;/users/yc/Desktop/code/abc/a/b/c/&#x27;)# 6. os.rmdir() 删除 空 文件夹# os.rmdir(&#x27;./a&#x27;) # a 是一个空文件夹# os.rmdir(&#x27;./b&#x27;) # b 是 含有一个文件夹的 目录 OSError: Directory not empty: &#x27;./b&#x27;# os.rmdir(&#x27;./c&#x27;) # c 是 含有一个文件的 目录 OSError: [Errno 66] Directory not empty: &#x27;./c&#x27;# 7. os.removedirs() 递归删除空文件夹&#x27;&#x27;&#x27;连续创建几个空文件abc/ def/ aaa/./abc/def/aaa/在mac系统中连续创建了abc目录后又在里面创建def，又在def里面创建aaa此时。使用os.removedirs(&#x27;./abc/def/aaa/&#x27;) 删除时，只删除了aaa。为什么？因为mac系统中的文件夹只要被使用过，都会默认创建一个隐藏文件 .DS_Store，因此这个文件夹不在是空文件夹了&#x27;&#x27;&#x27;# os.removedirs(&#x27;./abc/def/aaa/&#x27;)# 8. os.remove() 删除文件# os.remove(&#x27;./abc/.DS_Store&#x27;)# 9. os.rename() 修改文件或文件夹的名字# os.rename(&#x27;./a&#x27;,&#x27;./AAA&#x27;)# 10. os.system() 执行操作系统中的命令os.system(&#x27;python3 3.内置模块-数学模块-Math.py&#x27;)os.system(&#x27;ls&#x27;) os.path 路径模块1234567891011121314151617181920212223242526272829303132333435363738394041# os.path 系统模块中的路径模块import os# 将相对路径转化为绝对路径 ***res = os.path.abspath(&#x27;./&#x27;) # /Users/yc/Desktop/code# 获取路径中的主体部分 就是返回路径中的最后一部分res = os.path.basename(&#x27;/Users/yc/Desktop/code&#x27;) # coderes = os.path.basename(&#x27;/Users/yc/Desktop/code/1.py&#x27;) # 1.py# 获取路径中的路径部分 返回路径中最后一部分之前的内容res = os.path.dirname(&#x27;/Users/yc/Desktop/code/1.py&#x27;) # /Users/yc/Desktop/code# join() 链接多个路径，组成一个新的路径res = os.path.join(&#x27;./a/b/c/&#x27;,&#x27;2.jpg&#x27;) #./a/b/c/2.jpg# split() 拆分路径，把路径拆分为路径和主体部分，res = os.path.split(&#x27;./abc/def/aaa&#x27;) # (&#x27;./abc/def&#x27;, &#x27;aaa&#x27;)# splitext() 拆分路径，可以拆分文件后缀名res = os.path.splitext(&#x27;./a/b/c/2.jpg&#x27;)# 获取文件的大小 字节数res = os.path.getsize(&#x27;./3.内置模块-数学模块-Math.py&#x27;)# 检测是否是一个文件夹,是否存在res = os.path.isdir(&#x27;/Users/yc&#x27;)# 检测文件是否存在 ***res = os.path.isfile(&#x27;./3.内置模块-数学模块-Math.py&#x27;)# exists() **** 检测路径是否存在，既可以检测文件，也可以检测路径res = os.path.exists(&#x27;/Users/yc/Desktop/code/3.内置模块-数学模块-Math.py&#x27;)#a = &#x27;/Users/yc/Desktop/code/3.内置模块-数学模块-Math.py&#x27;b = &#x27;/Users/yc/../yc/Desktop/code/3.内置模块-数学模块-Math.py&#x27;# 检测两个path路径是否同时指向了一个目标位置 （两个路径必须真实）res = os.path.samefile(a,b)print(res) shutil 高级操作模块123456789101112131415161718192021# 。高级模块 shutilimport shutil# shutil == shell util#1 copy 复制文件 把一个文件拷贝到指定的目录中# shutil.copy(&#x27;./data.json&#x27;,&#x27;./a/da.json&#x27;)#2 copy2 和copy方法一样，可以把拷贝文件到指定目录，保留了原文件的信息（操作时间和权限等）#3 copyfile 拷贝文件的内容（打开文件，读取内容，写入到新的文件中）#4 copytree 可以把整个目录结构和文件全部拷贝到指定目录中，但是要求指定的目标目录必须不存在# shutil.copytree(&#x27;./a&#x27;,&#x27;./b/&#x27;)#5 rmtree() 删除整个文件夹# shutil.rmtree(&#x27;./a&#x27;)#6 move 移动文件或文件夹到指定目录，也可以用于修改文件夹或文件的名称shutil.move(&#x27;./b&#x27;,&#x27;./abc&#x27;) zipfile 压缩模块1234567891011121314151617181920212223242526# 压缩模块 zipfileimport zipfile,os# 压缩文件 操作# with zipfile.ZipFile(&#x27;spam1.zip&#x27;, &#x27;w&#x27;) as myzip:# myzip.write(&#x27;data.json&#x27;)# myzip.write(&#x27;data.txt&#x27;)# myzip.write(&#x27;data2.txt&#x27;)# 解压缩文件# with zipfile.ZipFile(&#x27;spam.zip&#x27;, &#x27;r&#x27;) as myzip:# myzip.extractall(&#x27;./&#x27;)# 如果压缩当前文件夹中的所有文件？# with zipfile.ZipFile(&#x27;spam.zip&#x27;, &#x27;w&#x27;,zipfile.ZIP_DEFLATED) as myzip:# # 获取当前目录中所有的项# arr = os.listdir(&#x27;./&#x27;)# for i in arr:# myzip.write(i)# # 使用shutil模块进行归档压缩# import shutil# # 参数1 创建的压缩文件名称，参数2，指定的压缩格式，zip，tar 参数3 要压缩的文件或文件夹路径# shutil.make_archive(&#x27;a&#x27;,&#x27;zip&#x27;,&#x27;./&#x27;) 内置模块-时间模块time 时间模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import time&#x27;&#x27;&#x27;概念： 1。 时间戳： 1574905882.6581771 表示从1970年1月1日0时0分0秒到现在的一个秒数，目前可以计算到2038年 2。 时间字符串： Thu Nov 12 09:54:08 2021 3。 时间元组： time.struct_time(tm_year=2021, tm_mon=11, tm_mday=12, tm_hour=9, tm_min=55, tm_sec=32, tm_wday=3, tm_yday=332, tm_isdst=0)&#x27;&#x27;&#x27;# *** 1. 获取当前系统的时间戳res = time.time()# 2. 获取当前系统时间，时间字符串res = time.ctime()# 3. 获取当前系统时间， 时间元组res = time.localtime()# 4. 以上时间字符串和时间元组可以通过指定的时间戳来获取t = 1564000082.6581771res = time.ctime(t)res = time.localtime()# 5. 使用localtime方法获取的时间元组，如何格式化成为 xxxx年xx月xx日 时：分：秒 星期几# print(f&#x27;&#123;res.tm_year&#125;年&#123;res.tm_mon&#125;月&#123;res.tm_mday&#125;日 &#123;res.tm_hour&#125;：&#123;res.tm_min&#125;：&#123;res.tm_sec&#125; 星期&#123;res.tm_wday+1&#125;&#x27;)# *** 6. strftime() 格式化时间 年-月-日 时：分：秒 星期几res = time.strftime(&#x27;%Y-%m-%d %H:%M:%S %w&#x27;)# *** 7。 sleep(秒) 在给定的秒数内暂停调用线程的执行。该参数可以是浮点数，以指示更精确的睡眠时间。# print(time.strftime(&#x27;%Y-%m-%d %H:%M:%S %w&#x27;))# time.sleep(3)# print(time.strftime(&#x27;%Y-%m-%d %H:%M:%S %w&#x27;))# 、计算程序的运行时间# time.perf_counter()# 100万次的字符串比较 需要执行的时间start = time.perf_counter()for i in range(1000000): if &#x27;abc&#x27; &gt; &#x27;acd&#x27;: passend = time.perf_counter()print(end-start) # 0.14171751# start = time.perf_counter()for i in range(1000000): if 103 &gt; 100 : passend = time.perf_counter()print(end-start) # 0.164985942 calendar 日历模块Re 正则表达式 正则表达式，就是使用字符，转义字符和特殊字符组成一个规则，使用这个规则对文本的内容完成一个搜索或匹配或替换的功能、 正则表达式的组成1234普通字符： 大小写字母，数字，符合。。。转义字符：\\w \\W \\d \\D \\s \\S ...特殊字符：. * ? + ^ $ [] &#123;&#125; ()匹配模式：I U。。。 示例： 123456789# 使用正则表达式进行匹配的 基本语法import re# 定义字符串vars = &#x27;helloworld# 定义正则表达式reg = &#x27;llo&#x27;# 调用正则函数方法res = re.findall(reg,vars)print(res) 正则表达式规则定义详解普通字符123456789# 正则表达式的规则定义import re# 普通字符# vars = &#x27;helloworld&#x27;# reg = &#x27;llo&#x27;# res = re.search(reg,vars).group()# print(res) 转义字符12345678910# 转义字符 \\w \\W \\d \\D \\s \\S ...varstr = &#x27;a2$_ilove5 21you&#x27;reg = &#x27;\\w&#x27; # 代表 单个 字母、数字、下划线reg = &#x27;\\W&#x27; # 代表 单个的 非 字母、数字、下划线reg = &#x27;\\d&#x27; # 代表 单个的 数字reg = &#x27;\\D&#x27; # 代表 单个的 非数字reg = &#x27;\\s&#x27; # 代表 单个的 空格符或制表符reg = &#x27;\\S&#x27; # 代表 单个的 非 空格符或制表符reg = &#x27;\\w\\w\\w\\w\\d&#x27; # 组合使用 特殊字符12345678910111213141516171819202122232425262728# 特殊字符 . * + ? &#123;&#125; [] () ^ $varstr = &#x27;hello WORLD iloveyou5211imissyou&#x27;reg = &#x27;.&#x27; # . 点 代表 单个的 任意字符 除了换行符之外reg = &#x27;\\w*&#x27; # * 代表匹配次数 任意次数reg = &#x27;\\w+&#x27; # + 代表匹配次数 至少要求匹配一次reg = &#x27;\\w+?&#x27; # ? 拒绝贪婪，就是前面的匹配规则只要达成则返回reg = &#x27;\\w*?&#x27;reg = &#x27;\\w&#123;5&#125;&#x27; # &#123;&#125; 代表匹配次数，&#123;4&#125; 一个数字时，表示必须匹配的次数reg = &#x27;\\w&#123;2,4&#125;&#x27; # &#123;&#125; 代表匹配次数，&#123;2,5&#125; 两个数字时，表示必须匹配的区间次数reg = &#x27;[A-Z,a-z,0-9,_]&#x27; # [] 代表字符的范围 [A-Z,a-z,0-9,_] == \\wreg = &#x27;\\w+(\\d&#123;4&#125;)(\\w+)&#x27; # () 代表子组，括号中的表达式首先作为整个正则的一部分，另外会把符合小括号中的内容单独提取一份varstr = &#x27;12345678111&#x27;# 定义一个匹配手机号的正则表达式reg = &#x27;^1\\d&#123;10&#125;$&#x27; # ^ 代表开头 $ 代表结尾# res = re.search(reg,varstr)# print(res.group())# print(res.groups())&#x27;&#x27;&#x27;*号的特点： 如果使用*号，那么在匹配的开始处如果符合要求， 则按照规则一直向后匹配，直到不符合匹配规则结束并把前面符合的数据返回 如果在匹配的开始处就不符合要求，则直接返回，匹配到的次数为0&#x27;&#x27;&#x27; 正则模式123456# 正则模式 re.I 不区分大小写vars = &#x27;HelloWorld&#x27;reg = &#x27;[a-z]&#123;5,10&#125;&#x27;res = re.search(reg,vars,re.I)print(res) re模块相关函数re.match() 函数 从头开始匹配 要么第一个就符合要求，要么不符合 匹配成功则返回Match对象，否则返回None 可以使用group()方法获取返回的数据 可以使用span()方法获取匹配的数据的下标区间 re.search() 函数+ 从字符串开头到结尾进行搜索式匹配 + 匹配成功则返回Match对象，否则返回None + 可以使用group()方法获取返回的数据 + 可以使用span()方法获取匹配的数据的下标区间 search() 和 match() 方法的区别：12match()方法是从字符串的开头进行匹配，如果开始就不符合正则的要求，则匹配失败，返回Nonesearch()方法是从字符串的开始位置一直搜索到字符串的最后，如果在整个字符串中都没有匹配到，则失败，返回None re.findall() 按照正则表达式的规则在字符中匹配所有符合规则的元素，结果返回一个列表，如果没有找到则返回空列表 re.finditer() 按照正则表达式的规则在字符中匹配所有符合规则的元素，返回一个迭代器 re.sub() 搜索替换 按照正则表达式的规则，在字符串中找到需要 被替换的字符串，完成一个替换 参数： pattern： 正则表达式的规则，匹配需要被替换的字符串 repl： 替换后的字符串 string： 被替换的原始字符串 compile()​ 可以直接将正则表达式定义为 正则对象，使用正则对象直接操作 示例： 123456789101112131415161718192021import re# 定义字符串varstr = &#x27;iloveyou521tosimida511&#x27;# 正则表达式reg = &#x27;\\d&#123;3&#125;&#x27;# 函数调用# res = re.findall(reg,varstr)# res = re.finditer(reg,varstr)# print(list(res))# 找到数字，替换成其它# res = re.sub(reg,&#x27;AAA&#x27;,varstr)# print(res)# 直接定义正则表达式对象reg = re.compile(&#x27;\\d&#123;3&#125;&#x27;)# 直接使用创建的正则对象，去调用对应的方法或函数res = reg.findall(string=varstr)# print(res) 练习题1234# 练习题：# 1。定义一个正则表达式，来验证邮箱是否正确# 2。完善 手机号的 正则表达式# 3。定义一个 匹配 IP 的正则表达式 192.168.1.1 255.255.255.0 Python中的模块与包模块 定义的一个python的文件，后缀名为.py。这个文件被称为模块。 模块中通常会定义一些相似的 类，函数等代码内容，提供给别的程序引入后使用。 系统模块 系统模块就是一个python的程序脚本，专门提供给我们自己的程序使用。它们是在安装好python环境时，就已经存在的，需要的时候可以使用 import 导入到程序中使用。 import logging，json，time。。。。 自定义模块 就是自己创建一个python脚本，定义一些类或方法，供别的脚本导入后使用。 例如定义一个My.py的文件如下 123456789101112# My.py# 定义类class MyException(): pass# 定义函数def func(): print(&#x27;我是一个模块中的func函数&#x27;) # 定义变量str = &#x27;hello&#x27; 在定义一个python脚本就可以引入上面的文件作为模块使用 main.py 123456789101112131415161718192021222324# main.py 在当前脚本中如果需要使用一些已经定义好的功能时，可以选择对应的模块，导入后使用# 使用系统模块 timeimport timeprint(time.time())# 使用自定义异常处理 模块import My# 使用模块中定义的类obj = My.MyException()print(obj)# 使用模块中的函数My.func()# 使用模块中定义的变量print(My.str)# 想使用模块中的内容时，除了导入模块，还可以在在指定模块中导入指定的内容from My import str # 导入My模块中的str变量from My import str as mystr # 导入My模块中的str变量，起个别名print(str)print(mystr) 模块中的测试代码1234567891011# 自定义模块中，通常只是去定义类或函数，变量，等，并不调用# 如果在自定义模块中，想要写一些测试代码，在当前模块作为主程序使用时执行，# 而作为模块被别的程序导入时不执行，那么可以把测试代码写到 下面代码块中if __name__ == &#x27;__main__&#x27;: print(&#x27;这个位置写的代码只有当前脚本被直接运行时触发&#x27;) # 特殊的变量 __name__# __name__ 这个变量，在当前脚本作为模块被别的程序导入是 __name__的值 是当前这个模块的名称#在当前脚本被作为主程序直接由python解析运行时，__name__的值 是 &#x27;__main__&#x27;name = __name__print(name) 包 包可以理解为是一个文件夹，里面包含了多个python文件。 包的结构：12345678910&#x27;&#x27;&#x27;package/ # 包(文件夹)├── __init__.py # 包中的初始化文件├── a.py # 包中的模块├── b.py└── ps/ # 子包 ├── __init__.py ├── c.py └── d.py&#x27;&#x27;&#x27; 包的使用方法123456789101112131415161718192021222324252627# 1. 直接把包当作模块导入，可以用的内容是 __init__.py文件中定义的# 不推荐这种用法import packagepackage.funcpa()#2。 可以导入模块中的所有内容# 注意这个内容是由 __init__.py文件中定义的 __all__ 这个变量指定的模块# 好处是可以直接导入指定的所以模块，并且使用时，直接使用指定的模块名即可from package import *a.funca()b.funcb()# 3。 导入指定包中的指定模块from package import aa.funca()# 4。从指定包的指定模块中导入指定的内容from package.b import funcbfuncb()# 5。从指定包的子包中导入模块from package.ps import cc.funcc()# 6。 从指定包的子包的指定模块中导入指定内容from package.ps.d import funcdfuncd() 导入方式的分类绝对导入1234567# 绝对导入的方式会使用[搜索路径]去查找和导入指定的包或模块import 模块import 包import 包.模块from 模块 import 内容from 包 import 模块from 包.模块 import 内容 相对导入注意：相对导入只能在非主程序的模块中使用，不需要直接运行的模块文件 123456# 相对导入 from .包名/模块名 import 模块/内容from ..包名/模块名 import 模块/内容. 代表当前..代表上一级 搜索路径 在导入模块或包时，程序查找的路径 123456789101112131415161718192021&#x27;&#x27;&#x27;主要的搜索路径1. 当前导入模块的程序所在的文件2. python的扩展目录中 C:/Users/username/AppData/local/.../Python37/lib3. python解释器指定的其它 第三方模块位置 /lib/sitepackages&#x27;&#x27;&#x27;# 在当前脚本中查看 包或模块 的 搜索路径import sysprint(sys.path)&#x27;&#x27;&#x27;[ &#x27;&#x27;, &#x27;/Library/Frameworks/Python.framework/Versions/3.7/lib/python37.zip&#x27;, &#x27;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7&#x27;, &#x27;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/lib-dynload&#x27;, &#x27;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages&#x27; ]&#x27;&#x27;&#x27;# 可以自己定义一个路径，加入到搜索路径中sys.path.append(&#x27;/Users/yc/Desktop&#x27;) 单入口程序 单入口程序是指整个程序都是经过一个主程序文件在运行，其它程序都封装成了包或模块 12345678910111213141516# 单入口文件是作为程序直接被运行的唯一文件，其它都是作为模块或包，被导入单入口中去执行&#x27;&#x27;&#x27;ATM/|---- main.py # 当前程序的主入口文件，单入口文件,唯一直接运行的文件|---- package/ # 主要程序模块包|---- |----- __init__.py # 包的初始化文件|---- |----- View.py # 视图函数模块|---- |----- Controller.py# 控制器模块|---- |----- Card.py # 银行卡模块|---- |----- User.py # 用户模块|---- databases/ # 数据存储文件夹|---- |---- user.txt|---- |---- user_id_card.txtmain是程序的主入口文件，会被直接作为主程序运行，所以main.py文件中必须使用 绝对导入 方式&#x27;&#x27;&#x27; Python中的第三方库的管理和虚拟环境第三方库的管理 python中比较牛逼的地方就是由大量的第三方库提供给你使用。 第三方库的管理网站 https://pypi.org/如何安装第三方库pip pip就是python的包管理工具，解决了包直接的依赖关系。可以方便的管理第三方库(包). 类似于PHP中Composer，或者Nodejs中的npm，或者Linux中的yum。 如何使用pippip install 包名（库名） 注意：如果有多个python环境的情况下，可能需要使用pip3 例如安装pymysql这个库 pip install pymysql 安装指定版本的包pip install 包名==版本 搜索已经安装的包pip show 包名 查看安装的所有包pip list 更换pip的镜像源123456789101112131415161718192021222324252627282930313233343536PIP 更换国内安装源pip国内的一些镜像 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/修改源方法：临时使用： 可以在使用pip的时候在后面加上-i参数，指定pip源 pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple永久修改： linux: 修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下：[global]timeout = 6000index-url = https://pypi.tuna.tsinghua.edu.cn/simpletrusted-host = pypi.tuna.tsinghua.edu.cnwindows: 直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，在pip 目录下新建文件pip.ini，内容如下或者按照网友的建议：win+R 打开用户目录%HOMEPATH%，在此目录下创建 pip 文件夹，在 pip 目录下创建 pip.ini 文件, 内容如下 [global]timeout = 6000index-url = https://pypi.tuna.tsinghua.edu.cn/simpletrusted-host = pypi.tuna.tsinghua.edu.cn 虚拟环境 虚拟环境就是在当前的系统环境中，去配置另外一个python的运行环境，是可以创建多个不同的虚拟环境。 python的虚拟环境相互独立，互不影响。 虚拟环境中可以在没有权限的情况下安装新的库（Linux系统中可能会出现的问题） 不同的应用可以使用不同的库或不同的版本。 虚拟环境中的库升级也不影响其它环境 虚拟环境可以作为一个项目的专有环境。在需要部署时，一键导出项目的所需要的包 如何去使用python的虚拟环境1。在pycharm中可以直接创建虚拟环境 2。自己安装独立的虚拟环境 创建虚拟环境 python -m venv 虚拟环境名 进入虚拟环境，激活虚拟环境 linux 123# 使用 source 命令 去执行 v1/bin/ 目录下的 activatelocalhost:code yc$ source v1/bin/activate(v1) localhost:code yc$ windows 12345# windows系统需要 进入 v1/Scripts/ 这个目录cd v1/Scripts/ # 运行 activate.bat 文件activate.bat(v1) F:\\code&gt; 接下来就可以在虚拟环境中安装一些包 pip install pymysql 查看是否安装了某个包 pip show pymysql 如果安装过则能显示信息。 退出虚拟环境 linux : deactivate Windows： 直接ctrl+c 导出当前环境中所有安装过的包 123456789101112131415161718# 查看所有安装的包pip list&#x27;&#x27;&#x27;Package Version------------ -------Click 7.0 Flask 1.1.1 itsdangerous 1.1.0 Jinja2 2.10.3 MarkupSafe 1.1.1 pip 19.0.3 PyMySQL 0.9.3 setuptools 40.8.0 Werkzeug 0.16.0 &#x27;&#x27;&#x27;# 导出所有包到文件pip freeze &gt; ./requirements.txt 删除环境 退出虚拟环境后，直接删除虚拟环境文件夹即可 异常什么是异常？ 异常简单理解，就是非正常，没有达到预期目标。异常是一个事件，并且这个异常事件在我们程序员的运行过程中出现，会影响我们程序正常执行。 异常分两种： 1. 语法错误导致的异常 2. 逻辑错误导致的异常 如何处理异常？ 如果错误发生的情况是可以预知的，那么就可以使用流程控制进行预防处理 12345#比如： 两个数字的运算，其中一个不是数字，运算就会出错。这时可以去判断来预防n2 = 3if isinstance(n2,int): res = 10+n2 print(res) 如果错误的发生条件不可预知，就可以使用 try。。。except。。 在错误发生时进行处理 123456789101112131415161718&#x27;&#x27;&#x27;语法：try: 可能发生异常错误的代码except: 如果发生异常则进入 except 代码块进行处理&#x27;&#x27;&#x27;# 假设读取的文件不存在，会发生错误，可以使用两种方式进行处理，# 1。可以在文件读取前先判断当前的文件是否存在# 2。也可以使用try 。。。 except。。在错误发生时进行处理try: with open(&#x27;./user.txt&#x27;,&#x27;r&#x27;) as fp: res = fp.read() print(res)except: print(&#x27;文件不存在&#x27;)print(&#x27;程序的继续执行。。。&#x27;) 注意：try。。except。。是在错误发生后进行的处理。和if有着根本性的区别。 Try… except… 详细用法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# try...except... 详细用法# 1.使用try...except 处理指定的异常。如果引发了非指定的异常，则无法处理try: s1 = &#x27;hello&#x27; int(s1) # 会引发 ValueErrorexcept ValueError as e:# except IndexError as e: #如果引发了非指定的异常，则无法处理 print(e)# 2. 多分支处理异常类.不同的异常会走向不同的except处理s1 = &#x27;hello&#x27;try: # int(s1) # ValueError s1[5] # IndexErrorexcept IndexError as e: print(&#x27;IndexError&#x27;,e)except KeyError as e: print(&#x27;KeyError&#x27;,e)except ValueError as e: print(&#x27;ValueError&#x27;,e)# 3.通用异常类 Exceptions1 = &#x27;world&#x27;try: int(s1)except Exception as e: print(&#x27;Exception ===&#x27;,e)# 4. 多分支异常类+通用异常类.这样引发异常后会按照从上往下的顺序去执行对应的异常处理类。s1 = &#x27;hello&#x27;try: # int(s1) # ValueError s1[5] # IndexErrorexcept IndexError as e: print(&#x27;IndexError&#x27;,e)except KeyError as e: print(&#x27;KeyError&#x27;,e)except ValueError as e: print(&#x27;ValueError&#x27;,e)except Exception as e: print(&#x27;Exception&#x27;,e)# 5. try...except...else...s1 = &#x27;hello&#x27;try: str(s1)except IndexError as e: print(&#x27;IndexError&#x27;,e)except ValueError as e: print(&#x27;ValueError&#x27;,e)except Exception as e: print(&#x27;Exception&#x27;,e)else: print(&#x27;try代码块中没有引发异常时，执行&#x27;)# 6.try...except..else..finally# finally 无论是否引发异常，都会执行。通常情况下用于执行一些清理工作。s1 = &#x27;hello&#x27;try: int(s1) print(&#x27;如果前面的代码引发了异常，这个代码块将不在继续执行。。&#x27;)except IndexError as e: print(&#x27;IndexError&#x27;,e)except ValueError as e: print(&#x27;ValueError&#x27;,e)except Exception as e: print(&#x27;Exception&#x27;,e)else: print(&#x27;try代码块中没有引发异常时，执行&#x27;)finally: print(&#x27;无论是否引发了异常，都会执行这个代码块&#x27;)print(&#x27;如果上面的代码有异常并且进行了处理，那么后面的代码将继续执行&#x27;)# 7。使用 raise ，主动抛出异常try: #可以使用 raise 主动抛出异常，并设置异常信息 raise Exception(&#x27;发生错误&#x27;)except Exception as e: print(&#x27;Exception&#x27;,e)#8。 assert 断言assert 1 == 1 # 如果后面的表达式正确，则什么也不做assert 2 == 1 # 如果后面的表达式错误，则直接抛出 AssertionError 自定义异常处理类 当异常出现时，对异常信息进行写入日志。 traceback 回溯模块 https://docs.python.org/3.7/library/traceback.htmllogging 日志模块 https://docs.python.org/3.7/library/logging.html123456789101112131415161718192021# 自定义异常日志处理类class Myexception(): def __init__(self): import traceback import logging # logging的基本配置 logging.basicConfig( filename=&#x27;./error.log&#x27;,# 日志存储的文件及目录 format=&#x27;%(asctime)s %(levelname)s \\n %(message)s&#x27;,# 格式化存储的日志格式 datefmt=&#x27;%Y-%m-%d %H:%M:%S&#x27; ) # 写入日志 logging.error(traceback.format_exc())# 使用自定义异常处理类try: int(&#x27;bb&#x27;)except: print(&#x27;在此处进行异常的处理&#x27;) Myexception() # 在异常处理的代码块中去调用自定义异常类 标准的异常类 异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告","categories":[{"name":"Python","slug":"Python","permalink":"https://rscuber.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://rscuber.github.io/tags/Python/"},{"name":"基础入门","slug":"基础入门","permalink":"https://rscuber.github.io/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]},{"title":"Python基础语法","slug":"python基础语法","date":"2021-11-21T02:33:11.000Z","updated":"2021-12-14T17:02:29.589Z","comments":true,"path":"archives/b8a3dfda.html","link":"","permalink":"https://rscuber.github.io/archives/b8a3dfda.html","excerpt":"认识python脚本 编写python程序的文件，称为python的脚本或程序要求当前的python脚本的文件后缀名必须是.py","text":"认识python脚本 编写python程序的文件，称为python的脚本或程序要求当前的python脚本的文件后缀名必须是.py pycharm使用注意 需要明确的知道你当前pycharm选择的python环境 注释 注释就是一段说明文字，并不会被执行在python的脚本中，开头的第一个字符如果是 # 那么就是注释了 print() 输出函数 print可以在程序中输出一些内容，字符串，数字。。。函数就是为了完成一些功能，例如：print就是为了输出数据 变量1234# 什么是变量？# 变量就是用一个英文字符串来记录或标记一些数据，并且这个被标记的数据是可以变化的# num = 10 的理解# 就是把数据 10 赋值给变量 num使用，之后就可以使用num来代替这个10的数据 命名规范变量的命名要有规范 变量名可以使用字母，数字，下划线_， 不能以数字开头 严格区分大小写 不要使用中文 不要使用关键字 if else True False print 另外 变量的命名规范适用于脚本名称和后期的函数名及其它命令规范 变量的定义方式 定义变量时 要注意遵守变量命名规范 123456#第一种 变量定义方式a = 10b = 20#第二种定义方式a,b = 30,40 思考：如何实现 以下两个变量的数据相互交换1234567891011121314151617181920212223# 定义两个变量a = 10b = 20# 交换两个变量的值# 。。。&#x27;&#x27;&#x27;普通方式，完成变量数据的交换1，把a变量的值 赋值给c ，此时 c变量中 就是 102，把b变量的值 赋值给a ， 此时 a变量中 就是 203，把c变量的值 赋值给b ， 此时 b变量中 就是 10&#x27;&#x27;&#x27;# c = a# a = b# b = c# 利用python定义比变量的语法来实现 变量的数据交换a,b = b,a python的数据类型什么是数据类型？ 数据类型就是数据的表现形式 比如 你好 就是一个字符串，200 就是一个数字 在程序当中除了这种常用的字符和数字外还有很多其它的数据表现形式 type() 函数，可以返回当前的数据类型123s = &#x27;iloveyou&#x27;res = type(s) print(res) # &lt;class &#x27;str&#x27;&gt; str == string 1. 字符串类型 单双引号都可以定义字符串 三引号也可以定义字符串 单双引号定义的字符串不能随意换行，需要在换行时指明换行符 字符串中的引号可以互相嵌套，但是不能嵌套自己（例如不能在单引号中嵌套单引号，除非转义） 字符串中可以使用转义字符，如 \\r \\n \\t … 如果不想在字符串中实现转义字符可以在字符定义时 加 love = r&#39;\\nihao \\shijie&#39; 123456789# 定义方式就是使用 单引号 或者 双引号love = &#x27;iloveyou&#x27;hello = &quot;你好 世界&quot;# 也可以使用三引号实现大字符串的定义，一般用于大文本字符串的定义，并且大字符串，可以换行s = &#x27;&#x27;&#x27;比如说这一个很长很长的文章内容。。。&#x27;&#x27;&#x27; 2.数字类型 int 整型 float 浮点类型 complex 复数 bool 布尔类型（True，False） 12345678910111213141516171819202122232425262728# 数字类型 Number&#x27;&#x27;&#x27;int 整型float 浮点类型complex 复数bool 布尔类型（True，False）&#x27;&#x27;&#x27;varn = 521varn = -1111varn = 3.1415926varn = 0x10 # 十六进制varn = b&#x27;001100111&#x27; # bytes# 复数varn = 5+6j # complex# 布尔类型 boolvarn = Truevarn = False# print(varn,type(varn))# 数值类型可以参与运算a = 10b = 20print(a+b) 3.List列表类型 列表用来表示一系列数据，例如： 需要记录一组数字或其它数据 列表中存储的数据可以是任意类型的 在需要记录多个数据时，可以使用中括号进行定义 [], 并且每个数据之间使用逗号分隔 , 例如以下数据，定义了几组数字 列表中存储的每一组数据，称为元素 列表中存储的数据，可以通过下标的方式进行获取 那么列表中元素的值可不可以存储一个列表,称为 二级列表（二维列表） 或者 多级列表 （多维列表） 123456&#x27;&#x27;&#x27;关于列表中的下标 0 1 2 3 4 [&#x27;a&#x27;,&#x27;b&#x27;,521,&#x27;pai&#x27;,3.1415926] -5 -4 -3 -2 -1&#x27;&#x27;&#x27; 4. tuple 元组类型的定义 在定义多个数据内容时，可以选择使用List列表类型 还可以使用元组类型来定义， 元组和列表非常像，都时用于存储多个数据时使用 元组使用小括号进行定义（），列表使用中括号进行定义 元组的最大特点就是值不能被改变 123vart = (1,2,3,&#x27;a&#x27;,&#x27;b&#x27;)# 元组的其它定义方式vart = 1,2,3 注意在定义元组时，如果元组中只有一个元素，那么需要加, 不然就不是元组类型了5.Dict字典类型 字典也是用于存储一组或多组数据时使用，使用大括号 {}来定义 字典是 键值对 的存储方式 name ：admin 键和值之间使用冒号进行分隔，多组键值对之间使用逗号分隔 键必须是字符串或数字类型，值可以是任意类型 键名不能重复，值可以重复 12345678910# 比如需要记录一本书的相关数据 书名，作者，价格，。。。vard = &#123;&#x27;title&#x27;:&#x27;&lt;&lt;鬼谷子&gt;&gt;&#x27;,&#x27;author&#x27;:&#x27;鬼谷子&#x27;,&#x27;price&#x27;:&#x27;29.99&#x27;&#125;# print(vard,type(vard))# &#123;&#x27;title&#x27;: &#x27;&lt;&lt;鬼谷子&gt;&gt;&#x27;, &#x27;author&#x27;: &#x27;鬼谷子&#x27;, &#x27;price&#x27;: &#x27;29.99&#x27;&#125; &lt;class &#x27;dict&#x27;&gt;# 获取字典中的值print(vard[&#x27;title&#x27;])# 字典中的键不能重复使用，否则会覆盖vard = &#123;&#x27;a&#x27;:10,&#x27;b&#x27;:10,&#x27;c&#x27;:20,&#x27;a&#x27;:&#x27;aa&#x27;,1:&#x27;abcdef&#x27;,&#x27;2&#x27;:&#x27;2222&#x27;&#125;# print(vard) tip: 在python之前的版本中，字典是无序的 6.set集合类型 set集合是一个 无序且元素不重复的 集合的数据类型 set集合使用 中括号或者set()方法来定义 如果需要定义一个空集合时 只能使用 set()方法,因为大括号时定义的空字典 集合主要用于运算，交集，差集，并集，对称集合 123456789101112131415161718a = &#123;1,2,3,&#x27;a&#x27;&#125;# 给集合添加元素# a.add(&#x27;b&#x27;)# 无法获取集合中的单个元素，但是可以添加和删除# a.discard(&#x27;a&#x27;)# print(a)# 检查当前的元素是否在集合中# print(1 in a)# 集合主要用于运算，交集，差集，并集，对称集合a = &#123;1,2,3,&#x27;a&#x27;,&#x27;b&#x27;&#125;b = &#123;1,&#x27;a&#x27;,22,33&#125;print(a &amp; b) # 交集 &#123;1, &#x27;a&#x27;&#125;print(a - b) # 差集 &#123;&#x27;b&#x27;, 2, 3&#125; a 集合有，b集合没有的print(a | b) # 并集 &#123;1, 2, 3, 33, &#x27;a&#x27;, &#x27;b&#x27;, 22&#125; 两个集合，放到一起，并且去重print(a ^ b) # 对称差集 &#123;33, 2, 3, &#x27;b&#x27;, 22&#125; 总结数据类型123456789101112131415161718&#x27;&#x27;&#x27;字符串 string数字类型 Number 整型 int 浮点 float 复数 布尔 bool列表 list元组 tuple字典 dict集合 set可变数据类型：列表，字典，集合不可不数据类型： 字符串，数字，元组容器类型数据 ： 字符串，列表，元组，集合，字典非容器类型数据： 数字，布尔类型&#x27;&#x27;&#x27; 数据类型转换 什么是数据类型转换？ 把一个数据类型转换为另一个数据类型，例如 字符串转为数字 为什么需要数据类型转换？ 因为不同的数据类型之间不能运算 数据类型转换的形式？ 自动类型转换 强制类型转换 自动类型转换12345678# 自动类型转换# 当两个不同的值进行运算时，结果会向更高的精度进行计算# True ==&gt; 整型 ==&gt; 浮点 ==&gt; 复数a = 123b = True # 在和数字运算时 True转为数字1，False转为数字 0# print(a+b)# print(12.5+22)# print(True+3.14) 强制类型转换 python中的每个数据类型都有对应的方法，可以对数据类型进行转换 str() 可以把所有的其它数据类型转换为字符串类型 int() 字符串转数字类型时，如果字符串中时纯数字，可以转换 其它容器类型不能转为数字int类型 float() 浮点类型的转换和int类型一样，不过转换的结果是浮点类型 bool() 可以把其它类型转换布尔类型的True或False 总结，哪些情况转bool的结果是 False &#39;&#39;,0,0.0,False,[],&#123;&#125;,(),set() list() 列表 数字类型是 非容器类型，不能转换为列表 字符串 转换为列表时 会把字符串中的每一个字符当做列表的元素 集合 可以转换为 list列表类型 元组 可以转换为 list列表类型 字典 可以转换为 list列表类型,只保留了字典中的键 tuple() 元组 数字类型 非容器类型，不能转换为元组 其它容器类型的数据进行转换时，和列表一样 set() 集合 数字类型 非容器类型，不能转换为 集合 字符串,列表，元组 可以转为 集合 结果是无序的 字典转换为集合时，只保留了字典的键 key dict() 字典 数字类型 非容器类型，不能转换为 字典 字符串不能直接转换为 字典 列表可以转换为字典，要求是一个二级列表，并且每个二级元素只能有两个值 元组可以转换为字典，要求是一个二级元组，并且每个二级元素只能有两个值 Python3 运算符什么是运算符？本章节主要说明Python的运算符。举个简单的例子 4 + 5 = 9 。 例子中，4 和 5 被称为操作数，”+“ 称为运算符。 Python语言支持以下类型的运算符: 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 运算符优先级 接下来让我们一个个来学习Python的运算符。 Python算术运算符 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 31 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -11 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 210 / 除 - x 除以 y b / a 输出结果 2.1 % 取模 - 返回除法的余数 b % a 输出结果 1 ** 幂 - 返回x的y次幂 a**b 为10的21次方 // 取整除 - 向下取接近除数的整数 &gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5 Python比较运算符 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 True。 &gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False。 &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。 (a &lt; b) 返回 True。 &gt;= 大于等于 - 返回x是否大于等于y。 (a &gt;= b) 返回 False。 &lt;= 小于等于 - 返回x是否小于等于y。 (a &lt;= b) 返回 True。 Python赋值运算符 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a //= 取整除赋值运算符 c //= a 等效于 c = c // a Python位运算符按位运算符是把数字看作二进制来进行计算的。bin()函数可以把数字转为二进制。 Python中的按位运算法则如下： 下表中变量 a 为 60，b 为 13二进制格式如下： 12345678910111213a = 0011 1100b = 0000 1101-----------------a&amp;b = 0000 1100a|b = 0011 1101a^b = 0011 0001~a = 1100 0011 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 \\ 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a \\ b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 Python逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False Python成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 Python身份运算符身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 注： id() 函数用于获取对象内存地址。 is 与 == 区别： is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 Python运算符优先级以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ \\ 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 注意：Pyhton3 已不支持 &lt;&gt; 运算符，可以使用 != 代替 二进制 二进制（binary）在数学和数字电路中指以2为基数的记数系统，以2为基数代表系统是二进位制的。这一系统中，通常用两个不同的符号0（代表零）和1（代表一）来表示 [1] 。数字电子电路中，逻辑门的实现直接应用了二进制，因此现代的计算机和依赖计算机的设备里都用到二进制。每个数字称为一个比特（Bit，Binary digit的缩写） 进制转换十进制转换为二进制 一个十进制整数转换为二进制数采用 “除2取余，逆序排列”法。 具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来 例如 125 转为 二进制 12345678125 / 2 = 62 余 162 / 2 = 31 余 031 / 2 = 15 余 115 / 2 = 7 余 17 / 2 = 3 余 13 / 2 = 1 余 11 / 2 = 0 余 1余数从低位到高位依此排列： 1 1 1 1 1 0 1 二进制转换为十进制 方法：“按权展开求和”。 该方法的具体步骤是先将二迸制的数写成加权系数展开式，而后根据十进制的加法规则进行求和 例如： 12345678910111213141516# 1 1 1 1 1 0 11==&gt; 1*2^6 + 641==&gt; 1*2^5 + 321==&gt; 1*2^4 + 161==&gt; 1*2^3 + 81==&gt; 1*2^2 + 40==&gt; 0*2^1 + 01==&gt; 1*2^0 + 1 = 125 Python位运算符按位运算符是把数字看作二进制来进行计算的。bin()函数可以把数字转为二进制。 Python中的按位运算法则如下： 下表中变量 a 为 60，b 为 13二进制格式如下： 12345678910111213a = 0011 1100b = 0000 1101-----------------a&amp;b = 0000 1100a|b = 0011 1101a^b = 0011 0001~a = 1100 0011 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 \\ 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a \\ b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 Python中的流程控制1.python语句的分类2.流程控制相关的分类3.顺序结构4.分支结构5.循环结构6.其他流程控制语句 1.python语句的分类1.单行代码 一行的python代码 2.代码块/组： 以冒号作为开始，用缩进划分相同作用域，这样的结构称之为代码块，是一个整体。 作用域是指作用范围。作用区域，使用了相同的缩进，即有相同的作用域。 缩进：一个table距离或者四个空格。 注意：代码块/组中严格区分空格和table，不能混合使用，必须只使用一种方式缩进！ 2.流程控制的分类流程控制：对计算机执行代码的管控就是流程控制。 分类：1.顺序结构 2.分支结构/选择结构 3.循环结构 3.顺序结构顺序结构是系统默认程序结构，自上而下执行 4.分支结构结构代码 a.单项分支 if 条件表达式: 一条python代码 一条python代码 一条python代码 ... b.双项分支 if 条件表达式： 一条python代码 一条python代码 一条python代码 ... else: 一条python代码 一条python代码 一条python代码 ... c.多项分支 if 条件表达式： 一条python代码 一条python代码 一条python代码 ... elif 条件表达式： 一条python代码 一条python代码 一条python代码 ... elif 条件表达式： 一条python代码 一条python代码 一条python代码 ... ... else: 一条python代码 一条python代码 一条python代码 ... c.巢装分支 例子： if 条件表达式： 代码语句 if 条件表达式: 代码语句 else: 代码语句 else： 代码语句 5.循环结构必须熟练掌握！ a.while型循环 基本结构： while 条件表达式: 代码内容 代码内容 代码内容 ... 带有变化条件的循环 1.声明变量var 2.while 进行变量var的判断: 代码内容 代码内容 代码内容 ... 3.变量var的改变操作 b.for..in循环(主要用于遍历容器类数据) for 自定义变量 in 容器数据: 代码内容,可以使用自定义变量 代码内容,可以使用自定义变量 代码内容,可以使用自定义变量 实例 12345678910111213141516171819202122sum1 = 0i = 1while i &lt;= 100: sum1 += i i += 1print(&quot;sum1 = &quot;, sum1)str = &#x27;qwe&#x27;for i in range(len(str)): print(str[i], end = &#x27; &#x27;)sum2 = 0for i in range(1, 101): sum2 += iprint(&quot;sum2 = &quot;, sum2)# 嵌套循环item = [[1, 3, 5], [11, 22, 33], [7, 8, 9]]for i in item: for j in i: print(j, end = &#x27; &#x27;)print() 执行结果: 123sum1 = 5050q w e sum2 = 50501 3 5 11 22 33 7 8 9 else语句的应用循环中可以使用else语句 while 条件表达式: 循环语句 循环语句 循环语句 ... else: 代码语句 代码语句 代码语句 ... 其他的流程控制语句1.break语句 2.continue语句 3.pass语句 特殊语句：1231.exit()2.quit()用于结束程序的执行，exit()和quit()之后的代码不会执行。在单纯的循环结构中的作用与break很像，但绝不能混为一谈！！！ 实例 12345678910111213141516171819# 二分查找算法def binary_search(arr, head, tail, target): while head &lt;= tail: mid = int((head + tail) &gt;&gt; 1) if arr[mid] == target: return mid elif arr[mid] &lt; target: head = mid + 1 else: tail = mid - 1 return -1arr = [1, 2, 3, 5, 7, 9]x = 5result = binary_search(arr, 0, len(arr) - 1, x)if result != -1: print(f&#x27;find &#123;x&#125; at &#123;result&#125;&#x27;)else: print(&#x27;Not find!&#x27;) 执行结果: 1find 5 at 3","categories":[{"name":"Python","slug":"Python","permalink":"https://rscuber.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://rscuber.github.io/tags/Python/"},{"name":"基础入门","slug":"基础入门","permalink":"https://rscuber.github.io/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]},{"title":"各排序算法效率测试","slug":"各排序算法效率测试","date":"2021-11-12T07:05:08.000Z","updated":"2021-12-09T09:31:24.469Z","comments":true,"path":"archives/3966e620.html","link":"","permalink":"https://rscuber.github.io/archives/3966e620.html","excerpt":"各排序时间用时对比","text":"各排序时间用时对比 mytest/mytest.h123456789101112131415161718192021222324252627#ifndef _MYTEST_H#define _MYTEST_H#define COLOUR(a, b) &quot;\\033[0;1;&quot; #b &quot;m&quot; a &quot;\\033[0m&quot;#define RED(a) COLOUR(a, 31)#define GREEN(a) COLOUR(a, 32)#define YELLOW(a) COLOUR(a, 33)#define BLUE(a) COLOUR(a, 34)#define PURPLE(a) COLOUR(a, 35)#define TEST(func, arr, n) __TEST(func, #func, arr, n)int check(int*, int);int *getRandData(int);typedef void (*Func)(int*, int, int);void __TEST( Func, const char *func_name, int *arr, int n);#endif mytest/mytest.c123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;mytest.h&gt;#include &lt;sort.h&gt;int check(int *arr, int n) &#123; for (int i = 1; i &lt; n; i++) &#123; if (arr[i] &lt; arr[i - 1]) return 0; &#125; return 1;&#125;int *getRandData(int n) &#123; int *arr = (int *)malloc(sizeof(int) * n); for (int i = 0; i &lt; n; i++) arr[i] = rand() % n; return arr;&#125;void __TEST( Func func, const char *func_name, int *arr, int n) &#123; int *temp = (int *)malloc(sizeof(int) * n); memcpy(temp, arr, sizeof(int) * n); long long begin = clock(); func(temp, 0, n - 1); long long end = clock(); if (check(temp, n)) &#123; printf(GREEN(&quot;[ OK ]&quot;)); &#125; else &#123; printf(RED(&quot;[ FAIL ]&quot;)); &#125; printf( &quot; &quot; BLUE(&quot;%s&quot;) &quot; &quot; YELLOW(&quot;%lld (ms)&quot;) &quot;\\n&quot;, func_name, 1000 * (end - begin) / CLOCKS_PER_SEC ); free(temp); return ;&#125; mytest/sort.h123456789101112131415161718192021#ifndef _SORT_H#define _SORT_H#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;void bubble_sort(int *, int, int);void select_sort(int *, int, int);void merge_sort(int *, int, int);void insert_sort(int *, int, int);void unguarded_insert_sort(int *, int, int);void downUpdate(int *, int, int);void heap_sort(int *, int, int);void quick_sort_v1(int *, int, int);void quick_sort_v2(int *, int, int);void quick_sort_v3(int *, int, int);void mixed_sort(int*, int, int);#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;mytest.h&gt;#include &lt;sort.h&gt;void bubble_sort(int *arr, int l, int r) &#123; int n = r - l + 1; int times = 1; for (int i = 1; times &amp;&amp; i &lt; n; i++) &#123; times = 0; for (int j = l; j &lt;= r - i; j++) &#123; if (arr[j] &lt;= arr[j + 1]) continue; swap(arr[j], arr[j + 1]); times = 1; &#125; &#125; return ;&#125;void select_sort(int *arr, int l, int r) &#123; for (int i = l; i &lt; r; i++) &#123; int ind = i; for (int j = i + 1; j &lt;= r; j++) &#123; if (arr[j] &lt; arr[ind]) ind = j; &#125; swap(arr[i], arr[ind]); &#125; return ;&#125;void merge_sort(int *arr, int l, int r) &#123; if (r - l &lt;= 1) &#123; if (arr[l] &gt; arr[r]) &#123; swap(arr[l], arr[r]); &#125; return ; &#125; int mid = (l + r) &gt;&gt; 1; merge_sort(arr, l, mid); merge_sort(arr, mid + 1, r); int *temp = (int *)malloc(sizeof(int) * (r - l + 1)); int p1 = l, p2 = mid + 1, k = 0; while (p1 &lt;= mid || p2 &lt;= r) &#123; if (p2 &gt; r || p1 &lt;= mid &amp;&amp; arr[p1] &lt;= arr[p2]) &#123; temp[k++] = arr[p1++]; &#125; else &#123; temp[k++] = arr[p2++]; &#125; &#125; memcpy(arr + l, temp, sizeof(int) * (r - l + 1)); free(temp); return ;&#125;void insert_sort(int *arr, int l, int r) &#123; for (int i = l + 1; i &lt;= r; i++) &#123; int j = i; while (j &gt; l &amp;&amp; arr[j] &lt; arr[j - 1]) &#123; swap(arr[j], arr[j - 1]); j--; &#125; &#125; return ;&#125;void unguarded_insert_sort(int *arr, int l, int r) &#123; int ind = l; for (int i = l + 1; i &lt;= r; i++) &#123; if (arr[i] &lt; arr[ind]) ind = i; &#125; while (ind &gt; l) &#123; swap(arr[ind], arr[ind - 1]); // 为了不影响insert_sort的稳定性 ind--; &#125; for (int i = l + 2; i &lt;= r; i++) &#123; int j = i; while (arr[j] &lt; arr[j - 1]) &#123; swap(arr[j], arr[j - 1]); j--; &#125; &#125; return ;&#125;void downUpdate(int *arr, int n, int ind) &#123; while ((ind &lt;&lt; 1) &lt;= n) &#123; int temp = ind, l = ind &lt;&lt; 1, r = ind &lt;&lt; 1 | 1; if (arr[l] &gt; arr[temp]) temp = l; if (r &lt;= n &amp;&amp; arr[r] &gt; arr[temp]) temp = r; if (ind == temp) break; swap(arr[ind], arr[temp]); ind = temp; &#125; return ;&#125;void heap_sort(int *arr, int l, int r) &#123; arr += (l - 1); int n = r - l + 1; for (int i = n &gt;&gt; 1; i &gt;= 1; i--) &#123; downUpdate(arr, n, i); &#125; for (int i = n; i &gt; 1; i--) &#123; swap(arr[1], arr[i]); downUpdate(arr, i - 1, 1); &#125; return ;&#125;void quick_sort_v1(int *arr, int l, int r) &#123; if (l &gt;= r) return ; int x = l, y = r, z = arr[l]; while (x &lt; y) &#123; while (x &lt; y &amp;&amp; arr[y] &gt; z) --y; if (x &lt; y) arr[x++] = arr[y]; while (x &lt; y &amp;&amp; arr[x] &lt; z) ++x; if (x &lt; y) arr[y--] = arr[x]; &#125; arr[x] = z; quick_sort_v1(arr, l, x - 1); quick_sort_v1(arr, x + 1, r); return ;&#125;//无监督,单边递归,三点取中int median(int *arr, int l, int r) &#123; int x = arr[l], y = arr[r], z = arr[(l + r) &gt;&gt; 1]; if (x &gt; y) swap(x, y); if (x &gt; z) swap(x, z); if (y &gt; z) swap(y, z); return y;&#125;void quick_sort_v2(int *arr, int l, int r) &#123; while (l &lt; r) &#123; int x = l, y = r, z = arr[(l + r) &gt;&gt; 1]; do &#123; while (arr[x] &lt; z) ++x; // 这里不能写= while (arr[y] &gt; z) --y; if (x &lt;= y) &#123; swap(arr[x], arr[y]); x++, y--; &#125; &#125; while (x &lt;= y); quick_sort_v2(arr, l, y); l = x; &#125; return ;&#125;void mixed_sort(int *arr, int l, int r) &#123; while (r - l &gt; 16) &#123; int x = l, y = r, z = median(arr, l, r); do &#123; while (arr[x] &lt; z) ++x; // 这里不能写= while (arr[y] &gt; z) --y; if (x &lt;= y) &#123; swap(arr[x], arr[y]); x++, y--; &#125; &#125; while (x &lt;= y); quick_sort_v2(arr, l, y); l = x; &#125; unguarded_insert_sort(arr, l, r); return ;&#125; sort_test.c123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;mytest/mytest.h&gt;#include &lt;mytest/sort.h&gt;int main() &#123; #define MAX_N 30000000 printf(PURPLE(&quot;%d random numbers: \\n&quot;), MAX_N); int *arr = getRandData(MAX_N); TEST(quick_sort_v1, arr, MAX_N); TEST(quick_sort_v2, arr, MAX_N); TEST(mixed_sort, arr, MAX_N); #undef MAX_N printf(&quot;\\n&quot;); #define MAX_N 100000 printf(PURPLE(&quot;%d random numbers: \\n&quot;), MAX_N); TEST(bubble_sort, arr, MAX_N); TEST(select_sort, arr, MAX_N); TEST(insert_sort, arr, MAX_N); TEST(unguarded_insert_sort, arr, MAX_N); TEST(merge_sort, arr, MAX_N); TEST(heap_sort, arr, MAX_N); TEST(quick_sort_v1, arr, MAX_N); TEST(quick_sort_v2, arr, MAX_N); TEST(mixed_sort, arr, MAX_N); #undef MAX_N return 0;&#125; makefile12345678910111213141516171819202122CC = gccCFLAGS1 = -g -c -I./CFLAGS2 = -g -c -I./mytestSRC = $(wildcard mytest/*.c)MAINOBJS = $(patsubst %.c, %.o, $(SRC)) sort_test.o#MAINOBJS = mytest/sort.o mytest/mytest.o sort_test.oprog = ./bin/sort_test.PHONY: clean runall: $(MAINOBJS) $(CC) $^ -o $(prog)%.o: %.c $(CC) $(CFLAGS2) $&lt; -o $@sort_test.o: sort_test.c $(CC) $(CFLAGS1) $&lt; -o $@clean: rm -f $(MAINOBJS) $(prog)run: $(prog)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://rscuber.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://rscuber.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"当我开始真正爱自己","slug":"当我开始真正爱自己","date":"2021-11-12T05:30:36.000Z","updated":"2021-12-09T09:30:10.145Z","comments":true,"path":"archives/f10451ec.html","link":"","permalink":"https://rscuber.github.io/archives/f10451ec.html","excerpt":"卓别林当我开始真正爱自己， 我才认识到，所有的痛苦和情感的折磨， 都只是提醒我：活着，不要违背自己的本心。 今天我明白了，这叫做“真实”。","text":"卓别林当我开始真正爱自己， 我才认识到，所有的痛苦和情感的折磨， 都只是提醒我：活着，不要违背自己的本心。 今天我明白了，这叫做“真实”。 当我开始真正爱自己， 我才懂得，把自己的愿望强加于人， 是多么的无礼，就算我知道，时机并不成熟， 那人也还没有做好准备， 就算那个人就是我自己。 今天我明白了，这叫做“尊重”。 当我开始真正爱自己， 我不再渴求不同的人生， 我知道任何发生在我身边的事情， 都是对我成长的邀请。 如今，我称之为“成熟”。 当我开始真正爱自己， 我才明白，我其实一直都在正确的时间， 正确的地方，发生的一切都恰如其分。 由此我得以平静。 今天我明白了，这叫做“自信”。 当我开始真正爱自己， 我不再牺牲自己的自由时间， 不再去勾画什么宏伟的明天。 今天我只做有趣和快乐的事， 做自己热爱，让心欢喜的事， 用我的方式、我的韵律。 今天我明白了，这叫做“单纯”。 当我开始真正爱自己， 我开始远离一切不健康的东西。 不论是饮食和人物，还是事情和环境， 我远离一切让我远离本真的东西。 从前我把这叫做“追求健康的自私自利”， 但今天我明白了，这是“自爱”。 当我开始真正爱自己， 我不再总想着要永远正确，不犯错误。 我今天明白了，这叫做“谦逊”。 当我开始真正爱自己， 我不再继续沉溺于过去， 也不再为明天而忧虑， 现在我只活在一切正在发生的当下， 今天，我活在此时此地， 如此日复一日。这就叫“完美”。 当我开始真正爱自己， 我明白，我的思虑让我变得贫乏和病态， 但当我唤起了心灵的力量， 理智就变成了一个重要的伙伴， 这种组合我称之为，“心的智慧”。 我们无须再害怕自己和他人的分歧， 矛盾和问题，因为即使星星有时也会碰在一起， 形成新的世界，今天我明白，这就是“生命”","categories":[{"name":"诗歌","slug":"诗歌","permalink":"https://rscuber.github.io/categories/%E8%AF%97%E6%AD%8C/"}],"tags":[{"name":"文学","slug":"文学","permalink":"https://rscuber.github.io/tags/%E6%96%87%E5%AD%A6/"},{"name":"诗歌","slug":"诗歌","permalink":"https://rscuber.github.io/tags/%E8%AF%97%E6%AD%8C/"}]},{"title":"我会采更多的雏菊","slug":"我会采更多的雏菊","date":"2021-11-11T17:05:26.000Z","updated":"2021-12-09T07:21:54.897Z","comments":true,"path":"archives/f54fd3e.html","link":"","permalink":"https://rscuber.github.io/archives/f54fd3e.html","excerpt":"纳丁·斯特尔如果我能够从头活过， 我会试着犯更多的错。","text":"纳丁·斯特尔如果我能够从头活过， 我会试着犯更多的错。 我会放松一点，我会灵活一点。 我会比这一趟过得傻。 很少有什么事情能让我当真。 我会疯狂一些，我会少讲点卫生。 我会冒更多的险。我会更经常的旅行。 我会爬更多的山，游更多的河，看更多的日落。 我会多吃冰激凌，少吃豆子。 我会惹更多的麻烦，可是不在想象中担忧。 你看，我小心翼翼地稳健地理智地活着。 一个又一个小时，一天又一天。 噢，我有过难忘的时刻。 如果我能够重来一次，我会要更多这样的时刻。 事实上，我不需要别的什么， 仅仅是时刻，一个接着一个。 而不是每天都操心着以后的漫长日子。 我曾经不论到哪里都不忘记带上： 温度计，热水壶，雨衣和降落伞。 如果我能够重来一次， 我会到处走走，什么都试试，并且轻装上阵。 如果我能够重头活过， 我会延长打赤脚的时光。 从尽早的春天到尽晚的秋天。 我会更经常的逃学。 我不会考那么高的分数，除非是一不小心。 我会多骑些旋转木马， 我会采更多的雏菊。","categories":[{"name":"诗歌","slug":"诗歌","permalink":"https://rscuber.github.io/categories/%E8%AF%97%E6%AD%8C/"}],"tags":[{"name":"文学","slug":"文学","permalink":"https://rscuber.github.io/tags/%E6%96%87%E5%AD%A6/"},{"name":"诗歌","slug":"诗歌","permalink":"https://rscuber.github.io/tags/%E8%AF%97%E6%AD%8C/"}]},{"title":"哈夫曼树与哈夫曼编码","slug":"哈夫曼树与哈夫曼编码","date":"2021-11-10T15:32:02.000Z","updated":"2021-12-09T09:26:56.401Z","comments":true,"path":"archives/ff8e2396.html","link":"","permalink":"https://rscuber.github.io/archives/ff8e2396.html","excerpt":"一、前置知识什么是编码‘a’ = 97 = $(0110 0001)_2$‘0’ = 48 = $(0011 0000)_2$ 注意：任何信息，在计算机中，都是二进制存储的","text":"一、前置知识什么是编码‘a’ = 97 = $(0110 0001)_2$‘0’ = 48 = $(0011 0000)_2$ 注意：任何信息，在计算机中，都是二进制存储的 信息：”aa00” = $01100001、01100001、00110000、00110000$ 一台计算机 传输到 另外一台计算机，传输 32 个比特位假设：计算机的网络是 32bit/s。所以用时：1 s特定场静：只有 a,b,0,1 四种字符需要传输特定编码：a:00, b: 01, 0: 10, 1: 11“aa00” = 00001010在带宽不变的情况下，当前只需要传输 0.25s 定长与变长编码 Ascii 编码 和 特定场景下的特定编码，都属于定长编码 UTF-8编码，是变长编码，UTF-16，是定长编码 对于每一个字符，编码长度不相同，这就是变长编码 将定长编码，看成是变长编码的特例 变长编码，一定不差于定长编码 变长编码应用场景特定场景： 只有四种字符 : ab01 a: 0.8, b: 0.05, 0: 0.1, 1: 0.05 平均编码长度：$l_i$：第 i 种字符，编码长度$p_i$：第 i 种字符，出现概率$avg(l) = \\sum{l_i}\\times{p_i}$ 假设，平均编码长度：1.16，估算传输100个字符，需要传输116个比特位特定编码的平均编码长度：$avg(l) = 2\\times\\sum{p_i}=2$ 新·特定编码：a: 1b: 010: 0001: 001 平均编码长度：$ 1\\times0.8+2\\times0.05+3\\times0.1+3\\times0.05=1.35 $100个字符，传输135个比特位 二、哈弗曼编码 首先，统计得到每一种字符的概率 将 n 个字符，建立成一棵哈弗曼树 每一个字符，都落在叶子结点上 按照左0，右1的形式，将编码读取出来 得到新编码：a: 0 | b: 110 | 0: 10 | 1: 111平均编码长度：$1\\times0.8+3\\times0.05+2\\times0.1+3\\times0.05=1.3$ 结论：哈弗曼编码，是最优的变长编码 三、公式证明求证： $\\sum_{i=1}^np_il_i$取得最⼩值时， $p_i$与$l_i$ 满⾜什么关系。其中： $l_i$ 表示第$i $种字符的编码⻓度， $p_i$表示第$i$种字符的出现概率 证明： ⾼度为$H$(从0开始) 的树，第$l$ 层的结点覆盖的叶⼦结点数为 $2^{H-l}$，第 $l$层的 $l$其实代表的就是编码⻓度。 所以得到约束条件为：$\\sum_{i=1}^{n}2^{H-l_i}\\leq2^H$ 。 $\\sum_{i=1}^{n}2^{H-l_i}\\leq2^H \\implies \\sum_{i=1}^{n}2^{-l_i}\\leq1$ 令 $L_i=2^{-l_i}$，得$\\sum_{i=1}^{n}{L_i}\\leq1$ 取对数得$l_i=-\\log_2{L_i}$ 所以 $\\sum_{i=1}^np_il_i=-\\sum_{i=1}^{n}p_i\\log_2{L_i}$ 问题转化为在约束条件 $\\sum_{i=1}^{n}{L_i}\\leq1$下，使 $-\\sum_{i=1}^{n}p_i\\log_2{L_i}$最⼩ 下⽤反证法证明当$\\sum_{i=1}^{n}{L_i}=1$ ，$-\\sum_{i=1}^{n}p_i\\log_2{L_i}$ 最⼩: 假设 $\\sum_{i=1}^{n}{L_i}0)$ 使得$L_x^\\prime+\\sum_{i=1}^{n}{L_i}=1$ 将 $L_x^\\prime$加到第$i$ 项得$L_1+L_2+\\cdots+(L_i+L_x^\\prime)+\\cdots+L_n=1$ 代⼊得:$-\\{p_1\\log_2{L_1}+p_2\\log_2{L_2}+\\cdots+p_i\\log_2{(L_i+L_x^\\prime)}+\\cdots+p_n\\log_2{L_n}\\}&lt;-\\sum_{i=1}^{n}p_i\\log_2{L_i}$ 这与 $-\\sum_{i=1}^{n}p_i\\log_2{L_i}$ 最⼩⽭盾，故假设不成⽴。 所以只有当约束条件为$\\sum_{i=1}^{n}{L_i}=1$ 下，⽬标函数$-\\sum_{i=1}^{n}p_i\\log_2{L_i}$ 才可能最⼩ 令 $\\Pi=\\sum_{i=1}^{n-1}{L_i}$，设⽬标函数$f(L_1,L_2,\\ldots,L_{n-1})=-\\{p_1\\log_2{L_1}+p_2\\log_2{L_2}+\\cdots+p_{n-1}\\log_2{L_{n-1}+p_n\\log_2(1-\\Pi)}\\}$ 对⽬标函数求偏导得: $\\frac{\\partial{f}}{\\partial{L_1}}=\\frac{p_n}{(1-\\Pi)\\ln2}-\\frac{p_1}{L_1\\ln2}$ $\\frac{\\partial{f}}{\\partial{L_2}}=\\frac{p_n}{(1-\\Pi)\\ln2}-\\frac{p_2}{L_2\\ln2}$ $\\vdots$ $\\frac{\\partial{f}}{\\partial{L_{n-1}}}=\\frac{p_{n}}{(1-\\Pi)\\ln2}-\\frac{p_{n-1}}{L_{n-1}\\ln2}$ 令 $\\frac{\\partial{f}}{\\partial{L_1}}=0, \\frac{\\partial{f}}{\\partial{L_2}}=0,\\cdots,\\frac{\\partial{f}}{\\partial{L_{n-1}}}=0$联⽴得$\\frac{p_1}{L_1}=\\frac{p2}{L_2}=\\cdots=\\frac{p_{n-1}}{L_{n-1}}=\\frac{p_n}{L_n}$ ， 设$\\frac{p_1}{L_1}=\\frac{p2}{L_2}=\\cdots=\\frac{p_{n-1}}{L_{n-1}}=\\frac{p_n}{L_n}=t$ 则$p_1=tL_1,p_2=tL_2,p_n=tL_n$ $\\begin{cases}\\sum_{i=1}^{n}{L_i}=1 \\ \\sum_{i=1}^{n}{p_i}=1\\end{cases} \\implies \\begin{cases}t=1 \\ t_i=p_i &amp; i=1,2,\\cdots,n \\end{cases}$ ⼜因为$L_i=2^{-l_i}$ ，所以$p_i=2^{-l_i}$ 因为函数$y=2^{-x}$ 是单调递减的 所以$l_i$ 越⼩， 越$p_i$⼤ 即字符的出现概率越⼤，对应字符的编码⻓度就越短。 编码⻓度严格按照对应符号出现的概率⼤⼩逆序排列时，则其平均码字⻓度为最⼩ 这种编码⽅式是最优的，即哈弗曼编码是最优的变⻓编码 四、代码实现哈夫曼树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;typedef struct Node &#123; char ch; double p; struct Node *lchild, *rchild;&#125; Node;Node *getNewNode(char ch, double p) &#123; Node *temp = (Node *)malloc(sizeof(Node)); temp-&gt;ch = ch; temp-&gt;p = p; temp-&gt;lchild = temp-&gt;rchild = NULL; return temp;&#125;Node *CombineNode(Node *a, Node *b) &#123; Node *temp = getNewNode(0, a-&gt;p + b-&gt;p); temp-&gt;lchild = a; temp-&gt;rchild = b; return temp;&#125;void pick_min(Node **arr, int k) &#123; int ind = k; for (int i = k - 1; i &gt;= 0; i--) &#123; if (arr[i]-&gt;p &lt; arr[ind]-&gt;p) &#123; ind = i; &#125; &#125; swap(arr[ind], arr[k]); return ;&#125;Node *getHuffmanTree(Node **arr, int n) &#123; //n个节点需要合并n-1次 for (int i = 1; i &lt; n; i++) &#123; //每次找到最小的两个节点放到最后 //这里用小顶堆更好 pick_min(arr, n - i); pick_min(arr, n - i - 1); arr[n - i -1] = CombineNode(arr[n - i], arr[n - i - 1]); &#125; return arr[0];&#125;void __output_code(Node *root, char *code, int k) &#123; code[k] = 0; if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) &#123; //如果是叶子节点, 则输出编码 printf(&quot;%c %s\\n&quot;, root-&gt;ch, code); return ; &#125; //左0右1 code[k] = &#x27;0&#x27;; __output_code(root-&gt;lchild, code, k + 1); code[k] = &#x27;1&#x27;; __output_code(root-&gt;rchild, code, k + 1); return ;&#125;void output_code(Node *root) &#123; char code[100]; __output_code(root, code, 0); return ;&#125;void clear(Node *root) &#123; if (root == NULL) return ; clear(root-&gt;lchild); clear(root-&gt;rchild); free(root); return ;&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); Node **arr = (Node **)malloc(sizeof(Node *) * n); for (int i = 0; i &lt; n; i++) &#123; char ch[10]; double p; scanf(&quot;%s%lf&quot;, ch, &amp;p); arr[i] = getNewNode(ch[0], p); &#125; Node *root = getHuffmanTree(arr, n); output_code(root); clear(root); free(arr); return 0;&#125; rand_input.cpp 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main() &#123; srand(time(0)); printf(&quot;26\\n&quot;); int sum, arr[26]; for (int i = 0; i &lt; 26; i++) &#123; arr[i] = rand() % 1000; sum += arr[i]; &#125; for (int i = 0; i &lt; 26; i++) &#123; printf(&quot;%c %lf\\n&quot;, i + &#x27;A&#x27;, 1.0 * arr[i] / sum); &#125; return 0;&#125; Input1234567891011121314151617181920212223242526272826A 0.034433B 0.040248C 0.007958D 0.003673E 0.072691F 0.061137G 0.030530H 0.072615I 0.027087J 0.040018K 0.008876L 0.059301M 0.065575N 0.063280O 0.049813P 0.042849Q 0.015303R 0.033285S 0.033591T 0.021807U 0.036116V 0.055934W 0.028311X 0.002449Y 0.071849Z 0.021272 Output1234567891011121314151617181920212223242526P 0000T 00010K 000110X 00011100D 00011101C 0001111O 0010I 00110W 00111V 0100L 0101F 0110N 0111G 10000R 10001M 1001S 10100A 10101Y 1011H 1100U 11010Q 110110Z 110111E 1110J 11110B 11111","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://rscuber.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://rscuber.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://rscuber.github.io/categories/Hexo/"},{"name":"诗歌","slug":"诗歌","permalink":"https://rscuber.github.io/categories/%E8%AF%97%E6%AD%8C/"},{"name":"英语","slug":"英语","permalink":"https://rscuber.github.io/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"Markdown","slug":"Markdown","permalink":"https://rscuber.github.io/categories/Markdown/"},{"name":"Python","slug":"Python","permalink":"https://rscuber.github.io/categories/Python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://rscuber.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://rscuber.github.io/tags/Hexo/"},{"name":"工具","slug":"工具","permalink":"https://rscuber.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"文学","slug":"文学","permalink":"https://rscuber.github.io/tags/%E6%96%87%E5%AD%A6/"},{"name":"诗歌","slug":"诗歌","permalink":"https://rscuber.github.io/tags/%E8%AF%97%E6%AD%8C/"},{"name":"英语","slug":"英语","permalink":"https://rscuber.github.io/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"长难句","slug":"长难句","permalink":"https://rscuber.github.io/tags/%E9%95%BF%E9%9A%BE%E5%8F%A5/"},{"name":"Markdown","slug":"Markdown","permalink":"https://rscuber.github.io/tags/Markdown/"},{"name":"Python","slug":"Python","permalink":"https://rscuber.github.io/tags/Python/"},{"name":"基础入门","slug":"基础入门","permalink":"https://rscuber.github.io/tags/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"name":"算法","slug":"算法","permalink":"https://rscuber.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://rscuber.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}